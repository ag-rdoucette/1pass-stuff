AWSTemplateFormatVersion: '2010-09-09'
Description: Secure 1Password Vault Request Approval System with CloudFront, Optional Custom Domain, WAF, and IP Restrictions

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Required: 1Password Configuration"
        Parameters:
          - OPServiceAccountToken
          - ApproverEmail
          - SenderEmail
      - Label:
          default: "Optional: Security Configuration"
        Parameters:
          - AllowedIPsCidr
          - WafWebAclArn
      - Label:
          default: "Optional: Custom Domain Configuration"
        Parameters:
          - CustomDomainName
          - AcmCertificateArn
          - CreateRoute53Record
          - Route53HostedZoneId
      - Label:
          default: "Optional: Application Configuration"
        Parameters:
          - ApprovalTokenTTLDays
          - StageName
      - Label:
          default: "Advanced: 1Password & Lambda Configuration"
        Parameters:
          - OPCliVersion
          - SecretName
          - SubmitApprovalMemory
          - CreatorMemory
          - SubmitApprovalTimeout
          - CreatorTimeout
    ParameterLabels:
      OPServiceAccountToken:
        default: "1Password Service Account Token"
      ApproverEmail:
        default: "Approver Email Address"
      SenderEmail:
        default: "SES Verified Sender Email"
      AllowedIPsCidr:
        default: "Allowed IP CIDR Blocks"
      WafWebAclArn:
        default: "Existing WAF WebACL ARN"
      CustomDomainName:
        default: "Custom Domain Name"
      AcmCertificateArn:
        default: "ACM Certificate ARN"
      ApprovalTokenTTLDays:
        default: "Approval Token TTL (Days)"
      StageName:
        default: "API Gateway Stage Name"

Parameters:
  # === REQUIRED: Core Configuration ===
  OPServiceAccountToken:
    Type: String
    NoEcho: true
    MinLength: 1
    Description: "REQUIRED: 1Password service account token (get from 1Password.com)"
  
  ApproverEmail:
    Type: String
    MinLength: 5
    Description: "REQUIRED: Email address that will receive vault approval requests"
    AllowedPattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    ConstraintDescription: "Must be a valid email address"
  
  SenderEmail:
    Type: String
    MinLength: 5
    Description: "REQUIRED: Verified SES sender email (must be verified in AWS SES first)"
    AllowedPattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    ConstraintDescription: "Must be a valid email address verified in SES"
  
  # === OPTIONAL: Security Configuration ===
  AllowedIPsCidr:
    Type: String
    Default: ""
    Description: "OPTIONAL: Comma-separated IP CIDR blocks to whitelist (e.g., 10.0.0.0/8,192.168.1.0/24). Creates WAF automatically"
  
  WafWebAclArn:
    Type: String
    Default: ""
    Description: "OPTIONAL: Existing AWS WAF WebACL ARN. Leave blank to auto-create WAF if AllowedIPsCidr is provided"
  
  # === OPTIONAL: Custom Domain Configuration ===
  CustomDomainName:
    Type: String
    Default: ""
    Description: "OPTIONAL: Custom domain (e.g., vaults.example.com). Leave blank to use CloudFront default domain"
  
  AcmCertificateArn:
    Type: String
    Default: ""
    Description: "OPTIONAL: ACM certificate ARN for custom domain. MUST be in us-east-1 region. Required if using custom domain"
  
  CreateRoute53Record:
    Type: String
    Default: "false"
    AllowedValues: ["true", "false"]
    Description: "Auto-create Route53 DNS record? (Only if domain is hosted in Route53 in this account)"
  
  Route53HostedZoneId:
    Type: String
    Default: ""
    Description: "OPTIONAL: Route53 Hosted Zone ID (required only if CreateRoute53Record is true)"
  
  # === OPTIONAL: Application Configuration ===
  ApprovalTokenTTLDays:
    Type: Number
    Default: 7
    MinValue: 1
    MaxValue: 90
    Description: "Days until approval links expire (1-90 days, recommended: 7)"
  
  StageName:
    Type: String
    Default: prod
    AllowedValues: [dev, test, staging, prod]
    Description: "API Gateway stage name (dev, test, staging, or prod)"
  
  # === ADVANCED: 1Password & Lambda Configuration ===
  OPCliVersion:
    Type: String
    Default: '2.32.0'
    Description: "1Password CLI version (leave default unless you need a specific version)"
  
  SecretName:
    Type: String
    Default: OPServiceToken
    MinLength: 1
    Description: "Name for the Secrets Manager secret that stores the 1Password token"
  
  SubmitApprovalMemory:
    Type: Number
    Default: 256
    AllowedValues: [128, 256, 512, 1024]
    Description: "Memory for Submit/Approval Lambdas in MB (128, 256, 512, or 1024)"
  
  CreatorMemory:
    Type: Number
    Default: 512
    AllowedValues: [256, 512, 1024, 2048]
    Description: "Memory for VaultCreator Lambda in MB (256, 512, 1024, or 2048)"
  
  SubmitApprovalTimeout:
    Type: Number
    Default: 30
    MinValue: 10
    MaxValue: 900
    Description: "Timeout for Submit/Approval Lambdas in seconds (10-900)"
  
  CreatorTimeout:
    Type: Number
    Default: 300
    MinValue: 60
    MaxValue: 900
    Description: "Timeout for VaultCreator Lambda in seconds (60-900, max 900)"

Conditions:
  HasCustomDomain: !Not [!Equals [!Ref CustomDomainName, ""]]
  HasCertificate: !Not [!Equals [!Ref AcmCertificateArn, ""]]
  HasWafAcl: !Not [!Equals [!Ref WafWebAclArn, ""]]
  HasIPRestriction: !Not [!Equals [!Ref AllowedIPsCidr, ""]]
  UseCustomDomain: !And
    - !Condition HasCustomDomain
    - !Condition HasCertificate
  CreateRoute53RecordCondition: !And
    - !Equals [!Ref CreateRoute53Record, "true"]
    - !Not [!Equals [!Ref Route53HostedZoneId, ""]]
    - !Condition UseCustomDomain
  CreateWafForIPs: !And
    - !Condition HasIPRestriction
    - !Not [!Condition HasWafAcl]
  UseWaf: !Or
    - !Condition CreateWafForIPs
    - !Condition HasWafAcl

Resources:
  # ============================================================================
  # API GATEWAY CLOUDWATCH LOGGING (Account-Level Configuration)
  # ============================================================================
  
  ApiGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: ManagedBy
          Value: CloudFormation

  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchRole.Arn

  # ============================================================================
  # SECRETS MANAGEMENT
  # ============================================================================
  
  OPSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AWS::StackName}-${SecretName}"
      Description: 1Password service account token
      SecretString: !Ref OPServiceAccountToken
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  # ============================================================================
  # IAM ROLES
  # ============================================================================
  
  SubmitApprovalRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-SubmitApprovalRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SubmitApprovalPolicies
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: DynamoDBAccess
                Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt RequestsTable.Arn
              - Sid: SQSAccess
                Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource: !GetAtt ApprovalQueue.Arn
              - Sid: SESAccess
                Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: '*'
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  CreatorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-CreatorRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CreatorPolicies
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: DynamoDBAccess
                Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt RequestsTable.Arn
              - Sid: SESAccess
                Effect: Allow
                Action:
                  - ses:SendEmail
                  - ses:SendRawEmail
                Resource: '*'
              - Sid: SecretsManagerAccess
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Sub "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${AWS::StackName}-${SecretName}*"
              - Sid: SQSAccess
                Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:ChangeMessageVisibility
                Resource: !GetAtt ApprovalQueue.Arn
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  UserGroupExportRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-UserGroupExportRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: UserGroupExportPolicies
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: SecretsManagerAccess
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Sub "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${AWS::StackName}-${SecretName}*"
              - Sid: S3Access
                Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub "arn:aws:s3:::${SiteBucket}/*"
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  # ============================================================================
  # CLOUDWATCH LOG GROUPS
  # ============================================================================
  
  SubmitRequestLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-SubmitRequestLambda'
      RetentionInDays: 30

  ApprovalHandlerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-ApprovalHandlerLambda'
      RetentionInDays: 30

  VaultCreatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-VaultCreatorLambda'
      RetentionInDays: 30

  UserGroupExportLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AWS::StackName}-UserGroupExportLambda'
      RetentionInDays: 30

  ApiGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/apigateway/${AWS::StackName}'
      RetentionInDays: 14

  # ============================================================================
  # DATA STORAGE
  # ============================================================================
  
  RequestsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-Requests"
      AttributeDefinitions:
        - AttributeName: RequestId
          AttributeType: S
      KeySchema:
        - AttributeName: RequestId
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        Enabled: true
        AttributeName: ExpirationTime
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  ApprovalQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub "${AWS::StackName}-ApprovalQueue"
      VisibilityTimeout: 1800
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  # ============================================================================
  # LAMBDA FUNCTIONS
  # ============================================================================
  
  SubmitRequestLambda:
    Type: AWS::Lambda::Function
    DependsOn: SubmitRequestLogGroup
    Properties:
      FunctionName: !Sub "${AWS::StackName}-SubmitRequestLambda"
      Handler: index.lambda_handler
      Role: !GetAtt SubmitApprovalRole.Arn
      Runtime: python3.12
      MemorySize: !Ref SubmitApprovalMemory
      Timeout: !Ref SubmitApprovalTimeout
      Environment:
        Variables:
          TABLE_NAME: !Ref RequestsTable
          APPROVER_EMAIL: !Ref ApproverEmail
          SENDER_EMAIL: !Ref SenderEmail
          API_URL: !Sub https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}
          APPROVAL_TOKEN_TTL_DAYS: !Ref ApprovalTokenTTLDays
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import uuid
          import urllib.parse
          import time

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])
          ses = boto3.client('ses')

          def lambda_handler(event, context):
              body = json.loads(event['body'])
              request_id = str(uuid.uuid4())
              token = str(uuid.uuid4())

              approval_ttl_days = int(os.environ.get('APPROVAL_TOKEN_TTL_DAYS', 7))
              approval_expiration = int(time.time()) + (approval_ttl_days * 24 * 60 * 60)
              record_expiration = int(time.time()) + (90 * 24 * 60 * 60)

              item = {
                  'RequestId': request_id,
                  'Status': 'pending',
                  'Details': body,
                  'ApprovalToken': token,
                  'ApprovalExpirationTime': approval_expiration,
                  'RequesterEmail': body['requesterEmail'],
                  'ExpirationTime': record_expiration
              }
              table.put_item(Item=item)

              api_url = os.environ['API_URL']
              approver_email_encoded = urllib.parse.quote(os.environ['APPROVER_EMAIL'])
              approve_link = f"{api_url}/approve?request_id={request_id}&action=approve&token={urllib.parse.quote(token)}&approver_email={approver_email_encoded}"
              deny_link = f"{api_url}/approve?request_id={request_id}&action=deny&token={urllib.parse.quote(token)}&approver_email={approver_email_encoded}"

              revoke_text = "YES - Administrators will be REVOKED" if body.get('revokeAdmins') else "NO - Administrators keep default access"
              
              assignments = body.get('assignments', [])
              
              groups_list = []
              users_list = []
              
              for assignment in assignments:
                  name = assignment.get('name', assignment.get('id'))
                  perms = ', '.join(assignment.get('permissions', []))
                  
                  if assignment.get('type') == 'group':
                      groups_list.append(f"{name} ({perms})")
                  elif assignment.get('type') == 'user':
                      users_list.append(f"{name} ({perms})")
              
              assignments_html = ""
              assignments_text = ""
              
              if groups_list:
                  assignments_html += f"<div class='info-row'><span class='label'>Groups ({len(groups_list)}):</span><br>"
                  assignments_html += '<br>'.join([f"&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ {g}" for g in groups_list])
                  assignments_html += "</div>"
                  
                  assignments_text += f"Groups ({len(groups_list)}):\n"
                  assignments_text += '\n'.join([f"  ‚Ä¢ {g}" for g in groups_list])
                  assignments_text += "\n"
              
              if users_list:
                  assignments_html += f"<div class='info-row'><span class='label'>Users ({len(users_list)}):</span><br>"
                  assignments_html += '<br>'.join([f"&nbsp;&nbsp;&nbsp;&nbsp;‚Ä¢ {u}" for u in users_list])
                  assignments_html += "</div>"
                  
                  assignments_text += f"Users ({len(users_list)}):\n"
                  assignments_text += '\n'.join([f"  ‚Ä¢ {u}" for u in users_list])
              
              email_body_text = f"""
              New Vault Request:
              Vault: {body['vaultName']}
              Description: {body.get('description', 'None provided')}
              {assignments_text}
              Revoke Administrators: {revoke_text}
              Requester: {body['requesterName']} ({body['requesterEmail']})
              Reason: {body.get('reason', 'None provided')}

              Approve: {approve_link}
              Deny: {deny_link}
              """
              
              email_body_html = f"""
              <html>
              <head>
                <style>
                  body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                  .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                  .header {{ background: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; }}
                  .info {{ background: #fff; padding: 15px; border-left: 4px solid #007bff; margin-bottom: 20px; }}
                  .info-row {{ margin: 8px 0; }}
                  .label {{ font-weight: bold; color: #555; }}
                  .buttons {{ margin-top: 30px; text-align: center; }}
                  .btn {{ display: inline-block; padding: 12px 30px; margin: 0 10px; text-decoration: none; border-radius: 5px; font-weight: bold; }}
                  .btn-approve {{ background: #28a745; color: white; }}
                  .btn-deny {{ background: #dc3545; color: white; }}
                  .btn:hover {{ opacity: 0.9; }}
                </style>
              </head>
              <body>
                <div class="container">
                  <div class="header">
                    <h2 style="margin: 0; color: #007bff;">üîê New 1Password Vault Request</h2>
                  </div>
                  
                  <div class="info">
                    <div class="info-row"><span class="label">Vault Name:</span> {body['vaultName']}</div>
                    <div class="info-row"><span class="label">Description:</span> {body.get('description', 'None provided')}</div>
                    {assignments_html}
                    <div class="info-row"><span class="label">Revoke Administrators:</span> {revoke_text}</div>
                    <div class="info-row"><span class="label">Requester:</span> {body['requesterName']} ({body['requesterEmail']})</div>
                    <div class="info-row"><span class="label">Reason:</span> {body.get('reason', 'None provided')}</div>
                  </div>
                  
                  <div class="buttons">
                    <a href="{approve_link}" class="btn btn-approve">‚úì Approve Request</a>
                    <a href="{deny_link}" class="btn btn-deny">‚úó Deny Request</a>
                  </div>
                  
                  <p style="text-align: center; color: #999; font-size: 12px; margin-top: 30px;">
                    Click one of the buttons above to approve or deny this vault request.
                  </p>
                </div>
              </body>
              </html>
              """

              ses.send_email(
                  Source=os.environ['SENDER_EMAIL'],
                  Destination={'ToAddresses': [os.environ['APPROVER_EMAIL']]},
                  Message={
                      'Subject': {'Data': f"Approve Vault: {body['vaultName']}"},
                      'Body': {
                          'Text': {'Data': email_body_text},
                          'Html': {'Data': email_body_html}
                      }
                  }
              )

              try:
                  ses.send_email(
                      Source=os.environ['SENDER_EMAIL'],
                      Destination={'ToAddresses': [body['requesterEmail']]},
                      Message={
                          'Subject': {'Data': 'Vault Request Submitted'},
                          'Body': {'Text': {'Data': f"Your request for vault '{body['vaultName']}' has been submitted for approval. You will be notified once it's processed."}}
                      }
                  )
              except Exception as e:
                  print(f"Failed to send requester confirmation: {str(e)}")

              return {
                  'statusCode': 200,
                  'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST'
                  },
                  'body': json.dumps({'message': 'Submitted'})
              }

  ApprovalHandlerLambda:
    Type: AWS::Lambda::Function
    DependsOn: ApprovalHandlerLogGroup
    Properties:
      FunctionName: !Sub "${AWS::StackName}-ApprovalHandlerLambda"
      Handler: index.lambda_handler
      Role: !GetAtt SubmitApprovalRole.Arn
      Runtime: python3.12
      MemorySize: !Ref SubmitApprovalMemory
      Timeout: !Ref SubmitApprovalTimeout
      Environment:
        Variables:
          TABLE_NAME: !Ref RequestsTable
          QUEUE_URL: !Ref ApprovalQueue
          SENDER_EMAIL: !Ref SenderEmail
          APPROVAL_TOKEN_TTL_DAYS: !Ref ApprovalTokenTTLDays
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import urllib.parse
          import time

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])
          sqs = boto3.client('sqs')
          ses = boto3.client('ses')

          def html_response(title, message, is_success=True, is_denial=False):
              if is_denial:
                  color = '#dc3545'
                  icon = '‚ùå'
              elif is_success:
                  color = '#28a745'
                  icon = '‚úÖ'
              else:
                  color = '#ffc107'
                  icon = '‚ö†Ô∏è'
              
              return f"""
              <!DOCTYPE html>
              <html lang="en">
              <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <title>{title}</title>
                  <style>
                      body {{
                          font-family: Arial, sans-serif;
                          display: flex;
                          justify-content: center;
                          align-items: center;
                          min-height: 100vh;
                          margin: 0;
                          background: #f5f5f5;
                      }}
                      .container {{
                          background: white;
                          padding: 40px;
                          border-radius: 8px;
                          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                          text-align: center;
                          max-width: 500px;
                      }}
                      h1 {{
                          color: {color};
                          margin-bottom: 20px;
                      }}
                      p {{
                          color: #666;
                          line-height: 1.6;
                      }}
                      .icon {{
                          font-size: 60px;
                          margin-bottom: 20px;
                      }}
                  </style>
              </head>
              <body>
                  <div class="container">
                      <div class="icon">{icon}</div>
                      <h1>{title}</h1>
                      <p>{message}</p>
                  </div>
              </body>
              </html>
              """

          def lambda_handler(event, context):
              query = event.get('queryStringParameters') or {}
              if not all(k in query for k in ['request_id', 'action', 'token']):
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'text/html',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': html_response(
                          'Invalid Request',
                          'Missing required parameters. Please use the link from the approval email.',
                          False
                      )
                  }

              request_id = query['request_id']
              action = query['action']
              token = urllib.parse.unquote(query['token'])
              
              approver_email = query.get('approver_email', 'unknown')

              response = table.get_item(Key={'RequestId': request_id})
              if 'Item' not in response or response['Item']['ApprovalToken'] != token:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'text/html',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': html_response(
                          'Invalid Request',
                          'This approval link is invalid or has expired. Please contact the system administrator.',
                          False
                      )
                  }

              item = response['Item']
              vault_name = item['Details']['vaultName']
              
              current_time = int(time.time())
              approval_expiration = item.get('ApprovalExpirationTime', 0)
              
              if current_time > approval_expiration:
                  return {
                      'statusCode': 400,
                      'headers': {
                          'Content-Type': 'text/html',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': html_response(
                          'Link Expired',
                          f"This approval link has expired. Approval links are valid for {os.environ.get('APPROVAL_TOKEN_TTL_DAYS', '7')} days. Please request a new approval.",
                          False
                      )
                  }
              
              if item['Status'] != 'pending':
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'text/html',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': html_response(
                          'Already Processed',
                          f"This vault request for '{vault_name}' has already been {item['Status']}.",
                          False
                      )
                  }

              new_status = 'approved' if action == 'approve' else 'denied'
              
              try:
                  table.update_item(
                      Key={'RequestId': request_id},
                      UpdateExpression='SET #s = :new_status, ApprovedBy = :approver, ApprovalTimestamp = :timestamp',
                      ConditionExpression='#s = :pending',
                      ExpressionAttributeNames={'#s': 'Status'},
                      ExpressionAttributeValues={
                          ':new_status': new_status,
                          ':pending': 'pending',
                          ':approver': approver_email,
                          ':timestamp': current_time
                      }
                  )
              except boto3.exceptions.Boto3Error:
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'text/html',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': html_response(
                          'Already Processed',
                          f"This request has already been processed by another approver.",
                          False
                      )
                  }

              try:
                  ses.send_email(
                      Source=os.environ['SENDER_EMAIL'],
                      Destination={'ToAddresses': [item['RequesterEmail']]},
                      Message={
                          'Subject': {'Data': f"Vault Request {new_status.capitalize()}"},
                          'Body': {'Text': {'Data': f"Your vault '{vault_name}' request was {new_status}."}}
                      }
                  )
              except Exception as e:
                  print(f"Failed to notify requester: {str(e)}")

              try:
                  from datetime import datetime
                  timestamp_str = datetime.fromtimestamp(current_time).strftime('%Y-%m-%d %H:%M:%S UTC')
                  ses.send_email(
                      Source=os.environ['SENDER_EMAIL'],
                      Destination={'ToAddresses': [approver_email]},
                      Message={
                          'Subject': {'Data': f"Confirmation: You {action}d vault request"},
                          'Body': {'Text': {'Data': f"This is a confirmation that you {action}d the vault request for '{vault_name}' at {timestamp_str}.\n\nRequester: {item['RequesterEmail']}\nAction: {action}\nTimestamp: {timestamp_str}"}}
                      }
                  )
              except Exception as e:
                  print(f"Failed to send approver confirmation: {str(e)}")

              if action == 'approve':
                  sqs.send_message(QueueUrl=os.environ['QUEUE_URL'], MessageBody=request_id)
                  success_msg = f"The vault request for '{vault_name}' has been approved! The vault will be created shortly and the requester will be notified."
                  is_denial = False
              else:
                  success_msg = f"The vault request for '{vault_name}' has been denied. The requester has been notified."
                  is_denial = True

              return {
                  'statusCode': 200,
                  'headers': {
                      'Content-Type': 'text/html',
                      'Access-Control-Allow-Origin': '*'
                  },
                  'body': html_response(
                      f'Request {new_status.capitalize()}',
                      success_msg,
                      True,
                      is_denial
                  )
              }

  VaultCreatorLambda:
    Type: AWS::Lambda::Function
    DependsOn: VaultCreatorLogGroup
    Properties:
      FunctionName: !Sub "${AWS::StackName}-VaultCreatorLambda"
      Handler: index.lambda_handler
      Role: !GetAtt CreatorRole.Arn
      Runtime: python3.12
      MemorySize: !Ref CreatorMemory
      Timeout: !Ref CreatorTimeout
      Environment:
        Variables:
          TABLE_NAME: !Ref RequestsTable
          SENDER_EMAIL: !Ref SenderEmail
          SECRET_NAME: !Sub "${AWS::StackName}-${SecretName}"
          OP_CLI_VERSION: !Ref OPCliVersion
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import subprocess
          import urllib.request
          import zipfile
          import io
          import stat

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])
          secrets = boto3.client('secretsmanager')
          ses = boto3.client('ses')

          OP_VERSION = os.environ['OP_CLI_VERSION']
          OP_URL = f"https://cache.agilebits.com/dist/1P/op2/pkg/v{OP_VERSION}/op_linux_amd64_v{OP_VERSION}.zip"
          OP_PATH = "/tmp/op"

          def download_op():
              if not os.path.exists(OP_PATH):
                  with urllib.request.urlopen(OP_URL) as resp:
                      with zipfile.ZipFile(io.BytesIO(resp.read())) as z:
                          z.extract("op", "/tmp")
                  os.chmod(OP_PATH, stat.S_IRUSR | stat.S_IXUSR | stat.S_IWUSR)

          def lambda_handler(event, context):
              for record in event['Records']:
                  request_id = record['body']
                  resp = table.get_item(Key={'RequestId': request_id})
                  if 'Item' not in resp:
                      continue
                  item = resp['Item']
                  details = item['Details']
                  requester_email = item['RequesterEmail']

                  token = secrets.get_secret_value(SecretId=os.environ['SECRET_NAME'])['SecretString']
                  os.environ['OP_SERVICE_ACCOUNT_TOKEN'] = token

                  op_config_dir = "/tmp/.op"
                  os.makedirs(op_config_dir, exist_ok=True)
                  os.chmod(op_config_dir, 0o700)
                  os.environ['OP_CONFIG_DIR'] = op_config_dir

                  download_op()

                  vault_name = details['vaultName']
                  description = details.get('description', '')

                  try:
                      create_cmd = [OP_PATH, 'vault', 'create', vault_name]
                      if description:
                          create_cmd += ['--description', description]
                      
                      result = subprocess.run(create_cmd, capture_output=True, text=True, check=True)
                      print(f"Vault '{vault_name}' created successfully")

                      assignments = details.get('assignments', [])
                      grant_errors = []
                      granted_count = 0
                      total_assignments = len(assignments)
                      
                      for assignment in assignments:
                          assign_type = assignment.get('type')
                          assign_id = assignment.get('id')
                          permissions = ','.join(assignment.get('permissions', []))
                          
                          if not permissions:
                              permissions = 'view_items,view_and_copy_passwords'
                          
                          try:
                              if assign_type == 'group':
                                  grant_result = subprocess.run(
                                      [OP_PATH, 'vault', 'group', 'grant', '--vault', vault_name,
                                       '--group', assign_id, '--permissions', permissions],
                                      capture_output=True, text=True, check=True
                                  )
                                  print(f"Granted permissions to group: {assign_id}")
                              elif assign_type == 'user':
                                  grant_result = subprocess.run(
                                      [OP_PATH, 'vault', 'user', 'grant', '--vault', vault_name,
                                       '--user', assign_id, '--permissions', permissions],
                                      capture_output=True, text=True, check=True
                                  )
                                  print(f"Granted permissions to user: {assign_id}")
                              granted_count += 1
                          except subprocess.CalledProcessError as e:
                              error_output = e.stderr if e.stderr else e.stdout if e.stdout else str(e)
                              grant_errors.append(f"{assignment.get('name', assign_id)}: {error_output}")
                              print(f"Failed to grant to {assign_id}: {error_output}")

                      status = 'completed'
                      msg = f"Vault '{vault_name}' created. Access granted to {granted_count}/{total_assignments} assignees."
                      
                      if grant_errors:
                          msg += f" Errors: {'; '.join(grant_errors[:3])}"
                      
                      if details.get('revokeAdmins'):
                          try:
                              revoke_result = subprocess.run(
                                  [OP_PATH, 'vault', 'group', 'revoke', '--vault', vault_name,
                                   '--group', 'Administrators'],
                                  capture_output=True, text=True, check=True
                              )
                              msg += " Administrators group access revoked."
                              print(f"Administrators group revoked from vault '{vault_name}'")
                          except subprocess.CalledProcessError as e:
                              error_output = e.stderr if e.stderr else e.stdout if e.stdout else ''
                              print(f"Warning: Failed to revoke Administrators: {error_output}")
                              msg += " (Warning: Could not revoke Administrators group)"
                      
                  except subprocess.CalledProcessError as e:
                      output = e.stderr if e.stderr else e.stdout if e.stdout else ''
                      if 'already exists' in output.lower():
                          status = 'completed'
                          msg = f"Vault '{vault_name}' already exists ‚Äì access assumed granted."
                      else:
                          status = 'failed'
                          msg = f"Failed: {output or str(e)}"
                          print(f"Command failed: {e.cmd}")
                          print(f"Stdout: {e.stdout}")
                          print(f"Stderr: {e.stderr}")
                  except Exception as e:
                      status = 'failed'
                      msg = f"Failed: {str(e)}"
                      print(f"Unexpected error: {str(e)}")

                  table.update_item(
                      Key={'RequestId': request_id},
                      UpdateExpression='SET #s = :s',
                      ExpressionAttributeNames={'#s': 'Status'},
                      ExpressionAttributeValues={':s': status}
                  )

                  try:
                      ses.send_email(
                          Source=os.environ['SENDER_EMAIL'],
                          Destination={'ToAddresses': [requester_email]},
                          Message={
                              'Subject': {'Data': f"Vault Request {status.capitalize()}"},
                              'Body': {'Text': {'Data': msg}}
                          }
                      )
                  except Exception as e:
                      print(f"Failed to notify requester: {str(e)}")

  UserGroupExportLambda:
    Type: AWS::Lambda::Function
    DependsOn: UserGroupExportLogGroup
    Properties:
      FunctionName: !Sub "${AWS::StackName}-UserGroupExportLambda"
      Handler: index.lambda_handler
      Role: !GetAtt UserGroupExportRole.Arn
      Runtime: python3.12
      MemorySize: 512
      Timeout: 300
      Environment:
        Variables:
          BUCKET_NAME: !Ref SiteBucket
          SECRET_NAME: !Sub "${AWS::StackName}-${SecretName}"
          OP_CLI_VERSION: !Ref OPCliVersion
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import subprocess
          import urllib.request
          import zipfile
          import io
          import stat

          s3 = boto3.client('s3')
          secrets = boto3.client('secretsmanager')

          OP_VERSION = os.environ['OP_CLI_VERSION']
          OP_URL = f"https://cache.agilebits.com/dist/1P/op2/pkg/v{OP_VERSION}/op_linux_amd64_v{OP_VERSION}.zip"
          OP_PATH = "/tmp/op"

          def download_op():
              if not os.path.exists(OP_PATH):
                  with urllib.request.urlopen(OP_URL) as resp:
                      with zipfile.ZipFile(io.BytesIO(resp.read())) as z:
                          z.extract("op", "/tmp")
                  os.chmod(OP_PATH, stat.S_IRUSR | stat.S_IXUSR | stat.S_IWUSR)

          def lambda_handler(event, context):
              token = secrets.get_secret_value(SecretId=os.environ['SECRET_NAME'])['SecretString']
              os.environ['OP_SERVICE_ACCOUNT_TOKEN'] = token

              op_config_dir = "/tmp/.op"
              os.makedirs(op_config_dir, exist_ok=True)
              os.chmod(op_config_dir, 0o700)
              os.environ['OP_CONFIG_DIR'] = op_config_dir

              download_op()

              bucket_name = os.environ['BUCKET_NAME']

              try:
                  user_result = subprocess.run(
                      [OP_PATH, 'user', 'list', '--format=json'],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  
                  users = json.loads(user_result.stdout)
                  
                  active_users = [
                      user for user in users 
                      if user.get('state', '').lower() != 'suspended'
                  ]
                  
                  print(f"Found {len(users)} total users, {len(active_users)} active")
                  
                  s3.put_object(
                      Bucket=bucket_name,
                      Key='users.json',
                      Body=json.dumps(active_users, indent=2),
                      ContentType='application/json',
                      CacheControl='max-age=3600'
                  )
                  
                  group_result = subprocess.run(
                      [OP_PATH, 'group', 'list', '--format=json'],
                      capture_output=True,
                      text=True,
                      check=True
                  )
                  
                  groups = json.loads(group_result.stdout)
                  
                  excluded_groups = ['Owners', 'Administrators', 'Recovery', 'Provision Managers']
                  filtered_groups = [
                      group for group in groups 
                      if group.get('name') not in excluded_groups
                  ]
                  
                  print(f"Found {len(groups)} total groups, {len(filtered_groups)} after filtering")
                  
                  s3.put_object(
                      Bucket=bucket_name,
                      Key='groups.json',
                      Body=json.dumps(filtered_groups, indent=2),
                      ContentType='application/json',
                      CacheControl='max-age=3600'
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'User and group lists exported successfully',
                          'users': len(active_users),
                          'groups': len(filtered_groups)
                      })
                  }
                  
              except subprocess.CalledProcessError as e:
                  print(f"OP CLI error: {e.stderr}")
                  raise
              except Exception as e:
                  print(f"Export error: {str(e)}")
                  raise

  # ============================================================================
  # S3 BUCKET & CLOUDFRONT (Website Hosting)
  # ============================================================================
  
  SiteBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-site-${AWS::AccountId}"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      VersioningConfiguration:
        Status: Enabled
      CorsConfiguration:
        CorsRules:
          - AllowedOrigins:
              - '*'
            AllowedMethods:
              - GET
              - HEAD
            AllowedHeaders:
              - '*'
            MaxAge: 3600
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "${AWS::StackName}-OAC"
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  SiteBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref SiteBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontServicePrincipal
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub "${SiteBucket.Arn}/*"
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub "arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}"

  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub "${AWS::StackName} Vault Request System"
        HttpVersion: http2and3
        Aliases: !If
          - UseCustomDomain
          - [!Ref CustomDomainName]
          - !Ref AWS::NoValue
        ViewerCertificate: !If
          - UseCustomDomain
          - AcmCertificateArn: !Ref AcmCertificateArn
            SslSupportMethod: sni-only
            MinimumProtocolVersion: TLSv1.2_2021
          - CloudFrontDefaultCertificate: true
        WebACLId: !If
          - CreateWafForIPs
          - !GetAtt WafWebAcl.Arn
          - !If
            - HasWafAcl
            - !Ref WafWebAclArn
            - !Ref AWS::NoValue
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt SiteBucket.RegionalDomainName
            OriginAccessControlId: !Ref CloudFrontOAC
            S3OriginConfig: {}
          - Id: ApiGatewayOrigin
            DomainName: !Sub "${RestApi}.execute-api.${AWS::Region}.amazonaws.com"
            CustomOriginConfig:
              HTTPSPort: 443
              OriginProtocolPolicy: https-only
              OriginSSLProtocols: [TLSv1.2]
        CacheBehaviors:
          - PathPattern: !Sub "/${StageName}/requests"
            TargetOriginId: ApiGatewayOrigin
            ViewerProtocolPolicy: https-only
            AllowedMethods: [GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE]
            CachedMethods: [GET, HEAD, OPTIONS]
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
            OriginRequestPolicyId: b689b0a8-53d0-40ab-baf2-68738e2966ac
            Compress: true
          - PathPattern: !Sub "/${StageName}/approve"
            TargetOriginId: ApiGatewayOrigin
            ViewerProtocolPolicy: https-only
            AllowedMethods: [GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE]
            CachedMethods: [GET, HEAD, OPTIONS]
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad
            OriginRequestPolicyId: b689b0a8-53d0-40ab-baf2-68738e2966ac
            Compress: true
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD, OPTIONS]
          CachedMethods: [GET, HEAD, OPTIONS]
          Compress: true
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf
        PriceClass: PriceClass_100
        DefaultRootObject: index.html
        CustomErrorResponses:
          - ErrorCode: 403
            ResponsePagePath: /index.html
            ResponseCode: 200
            ErrorCachingMinTTL: 300
          - ErrorCode: 404
            ResponsePagePath: /index.html
            ResponseCode: 200
            ErrorCachingMinTTL: 300
      Tags:
        - Key: Application
          Value: VaultRequestSystem
        - Key: Environment
          Value: !Ref StageName
        - Key: ManagedBy
          Value: CloudFormation

  # ============================================================================
  # DNS CONFIGURATION (Optional)
  # ============================================================================
  
  Route53Record:
    Type: AWS::Route53::RecordSet
    Condition: CreateRoute53RecordCondition
    Properties:
      HostedZoneId: !Ref Route53HostedZoneId
      Name: !Ref CustomDomainName
      Type: CNAME
      TTL: 300
      ResourceRecords:
        - !GetAtt CloudFrontDistribution.DomainName

  # ============================================================================
  # WAF (Web Application Firewall - Optional)
  # ============================================================================
  
  IPSet:
    Type: AWS::WAFv2::IPSet
    Condition: CreateWafForIPs
    Properties:
      Name: !Sub "${AWS::StackName}-AllowedIPs"
      Scope: CLOUDFRONT
      IPAddressVersion: IPV4
      Addresses: !Split [",", !Ref AllowedIPsCidr]
      Tags:
        - Key: Application
          Value: VaultRequestSystem

  WafWebAcl:
    Type: AWS::WAFv2::WebACL
    Condition: CreateWafForIPs
    Properties:
      Name: !Sub "${AWS::StackName}-WAF"
      Scope: CLOUDFRONT
      DefaultAction:
        Block: {}
      Rules:
        - Name: AllowListedIPs
          Priority: 0
          Statement:
            IPSetReferenceStatement:
              Arn: !GetAtt IPSet.Arn
          Action:
            Allow: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AllowListedIPs
      VisibilityConfig:
        SampledRequestsEnabled: true
        CloudWatchMetricsEnabled: true
        MetricName: !Sub "${AWS::StackName}-WAF"
      Tags:
        - Key: Application
          Value: VaultRequestSystem

  # ============================================================================
  # API GATEWAY
  # ============================================================================
  
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AWS::StackName}-VaultRequestApi"
      Description: API for vault requests and approvals
      Tags:
        - Key: Application
          Value: VaultRequestSystem

  RequestsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt RestApi.RootResourceId
      RestApiId: !Ref RestApi
      PathPart: requests

  ApproveResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt RestApi.RootResourceId
      RestApiId: !Ref RestApi
      PathPart: approve

  RequestsPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: POST
      ResourceId: !Ref RequestsResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SubmitRequestLambda.Arn}/invocations

  RequestsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref RequestsResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApproveGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: GET
      ResourceId: !Ref ApproveResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ApprovalHandlerLambda.Arn}/invocations

  ApproveOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref ApproveResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - RequestsPostMethod
      - RequestsOptionsMethod
      - ApproveGetMethod
      - ApproveOptionsMethod
    Properties:
      RestApiId: !Ref RestApi
      Description: Initial deployment

  ApiStage:
    Type: AWS::ApiGateway::Stage
    DependsOn: ApiGatewayAccount
    Properties:
      StageName: !Ref StageName
      DeploymentId: !Ref ApiDeployment
      RestApiId: !Ref RestApi
      AccessLogSetting:
        DestinationArn: !GetAtt ApiGatewayLogGroup.Arn
        Format: '$context.requestId $context.error.message $context.error.messageString'
      MethodSettings:
        - ResourcePath: '/*'
          HttpMethod: '*'
          LoggingLevel: INFO
          DataTraceEnabled: false
          MetricsEnabled: true
      Tags:
        - Key: Application
          Value: VaultRequestSystem

  ApiUsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    DependsOn: ApiStage
    Properties:
      UsagePlanName: !Sub "${AWS::StackName}-rate-limit"
      Description: Rate limiting for approval endpoint
      ApiStages:
        - ApiId: !Ref RestApi
          Stage: !Ref StageName
      Throttle:
        BurstLimit: 40
        RateLimit: 20

  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    Properties:
      Name: !Sub "${AWS::StackName}-key"
      Enabled: true
      Tags:
        - Key: Application
          Value: VaultRequestSystem

  UsagePlanKey:
    Type: AWS::ApiGateway::UsagePlanKey
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref ApiUsagePlan

  # ============================================================================
  # EVENT SOURCES & AUTOMATION
  # ============================================================================
  
  QueueEventSource:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt ApprovalQueue.Arn
      FunctionName: !Ref VaultCreatorLambda
      Enabled: true

  DailyExportRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "${AWS::StackName}-DailyExport"
      Description: Trigger daily export of 1Password users and groups
      ScheduleExpression: rate(1 day)
      State: ENABLED
      Targets:
        - Arn: !GetAtt UserGroupExportLambda.Arn
          Id: UserGroupExportTarget

  DailyExportPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref UserGroupExportLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DailyExportRule.Arn

  # ============================================================================
  # LAMBDA PERMISSIONS
  # ============================================================================
  
  SubmitLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SubmitRequestLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/POST/requests'

  ApprovalLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ApprovalHandlerLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/GET/approve'

  # ============================================================================
  # SSM PARAMETERS (Configuration Storage)
  # ============================================================================
  
  ApiUrlParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AWS::StackName}/api-url"
      Description: API Gateway URL for vault request system
      Type: String
      Value: !Sub https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}
      Tags:
        Application: VaultRequestSystem
        Environment: !Ref StageName

Outputs:
  # ============================================================================
  # PRIMARY URLs (Use These)
  # ============================================================================
  
  WebsiteURL:
    Description: "üåê Main URL for the vault request form (share this with users)"
    Value: !If
      - UseCustomDomain
      - !Sub "https://${CustomDomainName}"
      - !Sub "https://${CloudFrontDistribution.DomainName}"
    Export:
      Name: !Sub "${AWS::StackName}-WebsiteURL"
  
  # ============================================================================
  # CLOUDFRONT INFORMATION
  # ============================================================================
  
  CloudFrontDomain:
    Description: "CloudFront distribution domain name"
    Value: !GetAtt CloudFrontDistribution.DomainName
    Export:
      Name: !Sub "${AWS::StackName}-CloudFrontDomain"
  
  CloudFrontDistributionId:
    Description: "CloudFront distribution ID (for cache invalidation)"
    Value: !Ref CloudFrontDistribution
    Export:
      Name: !Sub "${AWS::StackName}-DistributionId"
  
  CacheInvalidationCommand:
    Description: "üí° Run this after uploading files to S3"
    Value: !Sub "aws cloudfront create-invalidation --distribution-id ${CloudFrontDistribution} --paths '/*'"
  
  # ============================================================================
  # S3 & FILE MANAGEMENT
  # ============================================================================
  
  S3BucketName:
    Description: "üì¶ S3 bucket name (upload index.html, users.json, groups.json here)"
    Value: !Ref SiteBucket
    Export:
      Name: !Sub "${AWS::StackName}-BucketName"
  
  # ============================================================================
  # API GATEWAY
  # ============================================================================
  
  ApiURL:
    Description: "üîó API Gateway URL (used in approval emails)"
    Value: !Sub https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}
    Export:
      Name: !Sub "${AWS::StackName}-ApiURL"
  
  ApiId:
    Description: "API Gateway ID"
    Value: !Ref RestApi
    Export:
      Name: !Sub "${AWS::StackName}-ApiId"
  
  # ============================================================================
  # RESOURCES FOR DEBUGGING
  # ============================================================================
  
  DynamoDBTableName:
    Description: "DynamoDB table name"
    Value: !Ref RequestsTable
    Export:
      Name: !Sub "${AWS::StackName}-TableName"
  
  ApprovalQueueUrl:
    Description: "SQS queue URL"
    Value: !Ref ApprovalQueue
    Export:
      Name: !Sub "${AWS::StackName}-QueueUrl"
  
  SubmitRequestLambdaArn:
    Description: "Submit Request Lambda ARN"
    Value: !GetAtt SubmitRequestLambda.Arn
    Export:
      Name: !Sub "${AWS::StackName}-SubmitLambdaArn"
  
  # ============================================================================
  # SECURITY STATUS
  # ============================================================================
  
  SecurityConfiguration:
    Description: "üîê Active security features"
    Value: !Sub
      - "HTTPS: ‚úì | Custom Domain: ${Domain} | WAF: ${Waf} | IP Restriction: ${IP} | Rate Limit: ‚úì | Token TTL: ${TTL}d | PITR: ‚úì | Logs: ‚úì"
      - Domain: !If [UseCustomDomain, "‚úì", "‚úó"]
        Waf: !If [UseWaf, "‚úì", "‚úó"]
        IP: !If [HasIPRestriction, "‚úì", "‚úó"]
        TTL: !Ref ApprovalTokenTTLDays