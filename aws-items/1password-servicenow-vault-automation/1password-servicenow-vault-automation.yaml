AWSTemplateFormatVersion: '2010-09-09'
Description: ServiceNow-Integrated 1Password Vault Request System

# ============================================================================
# PARAMETERS
# ============================================================================

Parameters:
  # === 1Password Configuration ===
  OPServiceAccountToken:
    Type: String
    NoEcho: true
    Description: 1Password service account token (secure)
  
  OPCliVersion:
    Type: String
    Default: '2.32.0'
    Description: 1Password CLI version to download
  
  SecretName:
    Type: String
    Default: OPServiceToken
    Description: Secrets Manager secret name
  
  # === Lambda Configuration ===
  LambdaMemory:
    Type: Number
    Default: 512
    Description: Memory for Lambdas (MB)
    MinValue: 256
    MaxValue: 10240
  
  LambdaTimeout:
    Type: Number
    Default: 300
    Description: Timeout for Lambdas (seconds)
    MinValue: 30
    MaxValue: 900
  
  # === API Configuration ===
  StageName:
    Type: String
    Default: prod
    AllowedValues:
      - dev
      - staging
      - prod
    Description: API Gateway stage name
  
  ApiKeyValue:
    Type: String
    NoEcho: true
    Description: API Key for ServiceNow authentication (optional but recommended)
    Default: ''
  
  # === Security Configuration ===
  AllowedIPRanges:
    Type: CommaDelimitedList
    Default: '0.0.0.0/0'
    Description: Comma-separated list of allowed IP ranges in CIDR format (e.g. 1.2.3.4/32,5.6.7.8/24). Use 0.0.0.0/0 to allow all IPs (not recommended for production)
  
  # === Monitoring Configuration ===
  AlertEmail:
    Type: String
    Default: ''
    Description: Email address for CloudWatch alerts (optional)

# ============================================================================
# CONDITIONS
# ============================================================================

Conditions:
  UseApiKey: !Not [!Equals [!Ref ApiKeyValue, '']]
  EnableAlerts: !Not [!Equals [!Ref AlertEmail, '']]
  EnableWAF: !Not [!Equals [!Join ['', !Ref AllowedIPRanges], '0.0.0.0/0']]

# ============================================================================
# RESOURCES
# ============================================================================

Resources:
  # ==========================================================================
  # SECRETS & STORAGE
  # ==========================================================================
  
  OPSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AWS::StackName}-${SecretName}"
      Description: 1Password service account token
      SecretString: !Ref OPServiceAccountToken
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  RequestsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "${AWS::StackName}-Requests"
      AttributeDefinitions:
        - AttributeName: RequestId
          AttributeType: S
        - AttributeName: ServiceNowTicket
          AttributeType: S
        - AttributeName: CreatedAt
          AttributeType: S
      KeySchema:
        - AttributeName: RequestId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: ServiceNowTicketIndex
          KeySchema:
            - AttributeName: ServiceNowTicket
              KeyType: HASH
            - AttributeName: CreatedAt
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        Enabled: true
        AttributeName: ExpirationTime
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  # ==========================================================================
  # IAM ROLES & POLICIES
  # ==========================================================================
  
  VaultLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-VaultLambdaRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: VaultLambdaPolicies
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: DynamoDBAccess
                Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: 
                  - !GetAtt RequestsTable.Arn
                  - !Sub "${RequestsTable.Arn}/index/*"
              - Sid: SecretsManagerAccess
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Sub "arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${AWS::StackName}-${SecretName}*"
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  VaultLambdaSNSPolicy:
    Type: AWS::IAM::Policy
    Condition: EnableAlerts
    Properties:
      PolicyName: VaultLambdaSNSPolicy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: SNSPublish
            Effect: Allow
            Action:
              - sns:Publish
            Resource: !Ref AlertTopic
      Roles:
        - !Ref VaultLambdaRole

  ApiGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-ApiGatewayCloudWatchRole"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  # ==========================================================================
  # CLOUDWATCH LOG GROUPS
  # ==========================================================================
  
  CreateVaultLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AWS::StackName}-CreateVault"
      RetentionInDays: 30

  GetStatusLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/${AWS::StackName}-GetStatus"
      RetentionInDays: 30

  WAFLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "aws-waf-logs-${AWS::StackName}"
      RetentionInDays: 7

  # ==========================================================================
  # LAMBDA FUNCTIONS
  # ==========================================================================
  
  CreateVaultLambda:
    Type: AWS::Lambda::Function
    DependsOn: CreateVaultLogGroup
    Properties:
      FunctionName: !Sub "${AWS::StackName}-CreateVault"
      Handler: index.lambda_handler
      Role: !GetAtt VaultLambdaRole.Arn
      Runtime: python3.12
      MemorySize: !Ref LambdaMemory
      Timeout: !Ref LambdaTimeout
      Environment:
        Variables:
          TABLE_NAME: !Ref RequestsTable
          SECRET_NAME: !Sub "${AWS::StackName}-${SecretName}"
          OP_CLI_VERSION: !Ref OPCliVersion
          SNS_TOPIC_ARN: !If [EnableAlerts, !Ref AlertTopic, '']
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import subprocess
          import urllib.request
          import zipfile
          import io
          import stat
          import uuid
          import time
          import re
          from datetime import datetime

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])
          secrets = boto3.client('secretsmanager')
          sns = boto3.client('sns')

          OP_VERSION = os.environ['OP_CLI_VERSION']
          OP_URL = f"https://cache.agilebits.com/dist/1P/op2/pkg/v{OP_VERSION}/op_linux_amd64_v{OP_VERSION}.zip"
          OP_PATH = "/tmp/op"
          SNS_TOPIC = os.environ.get('SNS_TOPIC_ARN', '')

          # Fixed permission assignments for specific groups/users
          # These will ALWAYS be granted to every vault created
          FIXED_PERMISSIONS = [
              {
                  'identifier': 'oiha25n4kwtwjtuflebbwk43iq',
                  'type': 'group',
                  'name': 'Owners',
                  'permissions': 'manage_vault'
              },
              {
                  'identifier': 'dhobz45fuwauqql7dtcakijwzq',
                  'type': 'group',
                  'name': 'Administrators',
                  'permissions': 'manage_vault'
              },
              {
                  'identifier': '7urbsw7hvbgpdovz4hbwld7wce',
                  'type': 'group',
                  'name': 'OktaGroup1',
                  'permissions': 'view_items,create_items,edit_items,archive_items,delete_items,view_and_copy_passwords,view_item_history,import_items,export_items,copy_and_share_items,print_items'
              },
              {
                  'identifier': '6xsmeeh6jab27ss5xm7bbgd6le',
                  'type': 'group',
                  'name': 'OktaGroup2',
                  'permissions': 'view_items,create_items,edit_items,archive_items,delete_items,view_and_copy_passwords,view_item_history,import_items,export_items,copy_and_share_items,print_items'
              }
          ]

          def log(level, message, **kwargs):
              """Structured logging for CloudWatch"""
              log_entry = {
                  'timestamp': datetime.utcnow().isoformat(),
                  'level': level,
                  'message': message,
                  **kwargs
              }
              print(json.dumps(log_entry))

          def send_alert(subject, message):
              """Send SNS alert if configured"""
              if SNS_TOPIC:
                  try:
                      sns.publish(TopicArn=SNS_TOPIC, Subject=subject, Message=message)
                  except Exception as e:
                      log('ERROR', 'Failed to send SNS alert', error=str(e))

          def download_op():
              """Download and setup 1Password CLI with retry logic"""
              if os.path.exists(OP_PATH):
                  log('INFO', '1Password CLI already downloaded')
                  return
              
              max_retries = 3
              for attempt in range(max_retries):
                  try:
                      log('INFO', f'Downloading 1Password CLI (attempt {attempt + 1}/{max_retries})')
                      with urllib.request.urlopen(OP_URL, timeout=30) as resp:
                          with zipfile.ZipFile(io.BytesIO(resp.read())) as z:
                              z.extract("op", "/tmp")
                      os.chmod(OP_PATH, stat.S_IRUSR | stat.S_IXUSR | stat.S_IWUSR)
                      log('INFO', '1Password CLI downloaded successfully')
                      return
                  except Exception as e:
                      log('ERROR', f'Failed to download CLI on attempt {attempt + 1}', error=str(e))
                      if attempt == max_retries - 1:
                          raise
                      time.sleep(2 ** attempt)

          def validate_vault_name(name):
              """Validate vault name meets 1Password requirements"""
              if not name:
                  return False, "Vault name cannot be empty"
              if len(name) > 64:
                  return False, "Vault name must be 64 characters or less"
              if not re.match(r'^[a-zA-Z0-9\s\-_]+$', name):
                  return False, "Vault name can only contain letters, numbers, spaces, hyphens, and underscores"
              return True, ""

          def validate_request(body):
              """Validate request body"""
              errors = []
              if 'vaultName' not in body:
                  errors.append("Missing required field: vaultName")
              if 'userEmail' not in body:
                  errors.append("Missing required field: userEmail")
              return len(errors) == 0, errors

          def run_op_command(cmd, description, retry_count=2):
              """Run 1Password CLI command with retry logic"""
              for attempt in range(retry_count):
                  try:
                      log('INFO', f'Running: {description} (attempt {attempt + 1}/{retry_count})', command=' '.join(cmd))
                      result = subprocess.run(cmd, capture_output=True, text=True, check=True, timeout=60)
                      log('INFO', f'Success: {description}', stdout=result.stdout[:200])
                      return result
                  except subprocess.TimeoutExpired:
                      log('ERROR', f'Timeout: {description}', attempt=attempt + 1)
                      if attempt == retry_count - 1:
                          raise
                      time.sleep(2)
                  except subprocess.CalledProcessError as e:
                      error_output = e.stderr if e.stderr else e.stdout if e.stdout else str(e)
                      log('ERROR', f'Failed: {description}', stderr=error_output[:500], attempt=attempt + 1)
                      if attempt == retry_count - 1:
                          raise
                      time.sleep(2)

          def validate_user_exists(email):
              """Validate that user email exists in 1Password and return their UUID"""
              try:
                  log('INFO', 'Validating user exists in 1Password', email=email)
                  result = subprocess.run(
                      [OP_PATH, 'user', 'get', email, '--format', 'json'],
                      capture_output=True,
                      text=True,
                      timeout=30
                  )
                  
                  if result.returncode == 0:
                      user_data = json.loads(result.stdout)
                      user_uuid = user_data.get('id', '')
                      log('INFO', 'User validated successfully', email=email, uuid=user_uuid)
                      return True, user_uuid, ""
                  else:
                      error_msg = f"User email '{email}' does not exist in 1Password"
                      log('ERROR', 'User validation failed', email=email, stderr=result.stderr)
                      return False, "", error_msg
              except Exception as e:
                  error_msg = f"Failed to validate user: {str(e)}"
                  log('ERROR', 'User validation error', email=email, error=str(e))
                  return False, "", error_msg

          def lambda_handler(event, context):
              request_id = None
              try:
                  body = json.loads(event.get('body', '{}'))
                  log('INFO', 'Received vault creation request', body=body)
                  
                  valid, errors = validate_request(body)
                  if not valid:
                      log('WARN', 'Request validation failed', errors=errors)
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'success': False, 'errors': errors, 'message': 'Request validation failed'})
                      }
                  
                  vault_name = body['vaultName']
                  valid, msg = validate_vault_name(vault_name)
                  if not valid:
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'success': False, 'errors': [msg], 'message': 'Vault name validation failed'})
                      }
                  
                  description = body.get('description', f'Vault {vault_name}')
                  user_email = body['userEmail']
                  servicenow_ticket = body.get('serviceNowTicket', '')
                  requester = body.get('requester', 'ServiceNow')
                  
                  request_id = str(uuid.uuid4())
                  log('INFO', 'Generated request ID', requestId=request_id, vaultName=vault_name, userEmail=user_email)
                  
                  expiration_time = int(time.time()) + (90 * 24 * 60 * 60)
                  table.put_item(Item={
                      'RequestId': request_id,
                      'ServiceNowTicket': servicenow_ticket,
                      'VaultName': vault_name,
                      'UserEmail': user_email,
                      'Status': 'processing',
                      'Requester': requester,
                      'CreatedAt': datetime.utcnow().isoformat(),
                      'ExpirationTime': expiration_time,
                      'Details': body
                  })
                  
                  log('INFO', 'Retrieving 1Password service account token')
                  token = secrets.get_secret_value(SecretId=os.environ['SECRET_NAME'])['SecretString']
                  os.environ['OP_SERVICE_ACCOUNT_TOKEN'] = token

                  op_config_dir = "/tmp/.op"
                  os.makedirs(op_config_dir, exist_ok=True)
                  os.chmod(op_config_dir, 0o700)
                  os.environ['OP_CONFIG_DIR'] = op_config_dir
                  download_op()

                  log('INFO', 'Validating user email exists in 1Password', email=user_email)
                  user_exists, user_uuid, error_msg = validate_user_exists(user_email)
                  
                  if not user_exists:
                      log('ERROR', 'User validation failed - aborting vault creation', email=user_email, error=error_msg)
                      table.update_item(
                          Key={'RequestId': request_id},
                          UpdateExpression='SET #status = :status, #result = :result, CompletedAt = :completed',
                          ExpressionAttributeNames={'#status': 'Status', '#result': 'Result'},
                          ExpressionAttributeValues={
                              ':status': 'failed',
                              ':result': {'success': False, 'error': error_msg, 'message': f'Cannot create vault: {error_msg}'},
                              ':completed': datetime.utcnow().isoformat()
                          }
                      )
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json', 'X-Request-Id': request_id},
                          'body': json.dumps({
                              'success': False,
                              'error': error_msg,
                              'message': 'Vault NOT created. User email must exist in 1Password.',
                              'requestId': request_id,
                              'userEmail': user_email
                          })
                      }
                  
                  log('INFO', 'User validated - proceeding with vault creation', email=user_email, uuid=user_uuid)

                  result = {
                      'requestId': request_id,
                      'serviceNowTicket': servicenow_ticket,
                      'vaultName': vault_name,
                      'success': False,
                      'message': '',
                      'details': {},
                      'warnings': [],
                      'permissions_granted': []
                  }

                  try:
                      create_cmd = [OP_PATH, 'vault', 'create', vault_name]
                      if description:
                          create_cmd += ['--description', description]
                      
                      run_op_command(create_cmd, 'Create vault')
                      result['details']['vaultCreated'] = True
                      log('INFO', 'Vault created successfully', vaultName=vault_name)

                      grant_errors = []
                      granted_count = 0
                      
                      try:
                          full_permissions = 'view_items,create_items,edit_items,archive_items,delete_items,view_and_copy_passwords,view_item_history,import_items,export_items,copy_and_share_items,print_items,manage_vault'
                          run_op_command(
                              [OP_PATH, 'vault', 'user', 'grant', '--vault', vault_name,
                               '--user', user_uuid, '--permissions', full_permissions],
                              f'Grant full permissions to user {user_email}'
                          )
                          granted_count += 1
                          result['permissions_granted'].append({
                              'type': 'user',
                              'identifier': user_email,
                              'uuid': user_uuid,
                              'permissions': 'ALL (including manage_vault)',
                              'status': 'success'
                          })
                          log('INFO', 'Granted full permissions to requesting user', email=user_email, uuid=user_uuid)
                      except Exception as e:
                          error_msg = str(e)
                          grant_errors.append({'type': 'user', 'id': user_email, 'uuid': user_uuid, 'error': error_msg})
                          result['permissions_granted'].append({
                              'type': 'user',
                              'identifier': user_email,
                              'uuid': user_uuid,
                              'permissions': 'ALL (including manage_vault)',
                              'status': 'failed',
                              'error': error_msg
                          })
                          log('ERROR', 'Failed to grant permissions to requesting user', email=user_email, uuid=user_uuid, error=error_msg)
                      
                      for assignment in FIXED_PERMISSIONS:
                          try:
                              if assignment['type'] == 'group':
                                  run_op_command(
                                      [OP_PATH, 'vault', 'group', 'grant', '--vault', vault_name,
                                       '--group', assignment['identifier'], '--permissions', assignment['permissions']],
                                      f"Grant permissions to group {assignment['name']}"
                                  )
                              else:
                                  run_op_command(
                                      [OP_PATH, 'vault', 'user', 'grant', '--vault', vault_name,
                                       '--user', assignment['identifier'], '--permissions', assignment['permissions']],
                                      f"Grant permissions to user {assignment['name']}"
                                  )
                              
                              granted_count += 1
                              result['permissions_granted'].append({
                                  'type': assignment['type'],
                                  'name': assignment['name'],
                                  'identifier': assignment['identifier'],
                                  'permissions': assignment['permissions'],
                                  'status': 'success'
                              })
                              log('INFO', f"Granted permissions to {assignment['type']}", name=assignment['name'])
                          except Exception as e:
                              error_msg = str(e)
                              grant_errors.append({
                                  'type': assignment['type'],
                                  'name': assignment['name'],
                                  'identifier': assignment['identifier'],
                                  'error': error_msg
                              })
                              result['permissions_granted'].append({
                                  'type': assignment['type'],
                                  'name': assignment['name'],
                                  'identifier': assignment['identifier'],
                                  'permissions': assignment['permissions'],
                                  'status': 'failed',
                                  'error': error_msg
                              })
                              log('ERROR', f"Failed to grant permissions to {assignment['type']}", name=assignment['name'], error=error_msg)

                      total_expected = len(FIXED_PERMISSIONS) + 1
                      result['details']['permissionsGranted'] = granted_count
                      result['details']['permissionsExpected'] = total_expected
                      
                      if grant_errors:
                          result['details']['grantErrors'] = grant_errors
                          result['warnings'].append(f'{len(grant_errors)} permission grant(s) failed')
                      
                      if granted_count == 0:
                          result['success'] = False
                          result['message'] = f"Vault '{vault_name}' created but NO permissions were granted"
                          status = 'partial'
                      elif granted_count < total_expected:
                          result['success'] = True
                          result['message'] = f"Vault '{vault_name}' created. Permissions granted to {granted_count}/{total_expected} entities."
                          status = 'partial'
                      else:
                          result['success'] = True
                          result['message'] = f"Vault '{vault_name}' created successfully. All {granted_count} permissions granted."
                          status = 'completed'
                      
                  except subprocess.CalledProcessError as e:
                      error_output = e.stderr if e.stderr else e.stdout if e.stdout else str(e)
                      if 'already exists' in error_output.lower():
                          result['success'] = True
                          result['message'] = f"Vault '{vault_name}' already exists. No changes made."
                          result['details']['vaultCreated'] = False
                          result['details']['vaultExisted'] = True
                          status = 'completed'
                          log('WARN', 'Vault already exists', vaultName=vault_name)
                      else:
                          result['success'] = False
                          result['message'] = f"Failed to create vault: {error_output[:200]}"
                          result['details']['error'] = error_output
                          status = 'failed'
                          log('ERROR', 'Vault creation failed', error=error_output)
                          send_alert(f'Vault Creation Failed: {vault_name}', f'Request ID: {request_id}\nVault: {vault_name}\nError: {error_output[:500]}')
                  
                  table.update_item(
                      Key={'RequestId': request_id},
                      UpdateExpression='SET #status = :status, #result = :result, CompletedAt = :completed',
                      ExpressionAttributeNames={'#status': 'Status', '#result': 'Result'},
                      ExpressionAttributeValues={
                          ':status': status,
                          ':result': result,
                          ':completed': datetime.utcnow().isoformat()
                      }
                  )
                  
                  log('INFO', 'Request completed', requestId=request_id, status=status, vaultName=vault_name)
                  
                  return {
                      'statusCode': 200 if result['success'] else 500,
                      'headers': {'Content-Type': 'application/json', 'X-Request-Id': request_id},
                      'body': json.dumps(result)
                  }
                  
              except Exception as e:
                  error_msg = str(e)
                  log('ERROR', 'Unexpected error', error=error_msg, requestId=request_id)
                  
                  if request_id:
                      try:
                          table.update_item(
                              Key={'RequestId': request_id},
                              UpdateExpression='SET #status = :status, #result = :result, CompletedAt = :completed',
                              ExpressionAttributeNames={'#status': 'Status', '#result': 'Result'},
                              ExpressionAttributeValues={
                                  ':status': 'failed',
                                  ':result': {'success': False, 'error': error_msg},
                                  ':completed': datetime.utcnow().isoformat()
                              }
                          )
                      except Exception as db_error:
                          log('ERROR', 'Failed to update DynamoDB', error=str(db_error))
                  
                  send_alert('Vault Lambda Error', f'Request ID: {request_id}\nError: {error_msg}')
                  
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json', 'X-Request-Id': request_id or 'unknown'},
                      'body': json.dumps({'success': False, 'error': error_msg, 'message': 'Internal server error', 'requestId': request_id})
                  }

  GetStatusLambda:
    Type: AWS::Lambda::Function
    DependsOn: GetStatusLogGroup
    Properties:
      FunctionName: !Sub "${AWS::StackName}-GetStatus"
      Handler: index.lambda_handler
      Role: !GetAtt VaultLambdaRole.Arn
      Runtime: python3.12
      MemorySize: 256
      Timeout: 30
      Environment:
        Variables:
          TABLE_NAME: !Ref RequestsTable
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from datetime import datetime

          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TABLE_NAME'])

          def log(level, message, **kwargs):
              log_entry = {'timestamp': datetime.utcnow().isoformat(), 'level': level, 'message': message, **kwargs}
              print(json.dumps(log_entry))

          def lambda_handler(event, context):
              try:
                  params = event.get('queryStringParameters', {}) or {}
                  request_id = params.get('requestId')
                  servicenow_ticket = params.get('serviceNowTicket')
                  
                  log('INFO', 'Status check request', requestId=request_id, ticket=servicenow_ticket)
                  
                  if not request_id and not servicenow_ticket:
                      return {
                          'statusCode': 400,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'success': False, 'error': 'Either requestId or serviceNowTicket parameter is required'})
                      }
                  
                  if request_id:
                      response = table.get_item(Key={'RequestId': request_id})
                      item = response.get('Item')
                  else:
                      response = table.query(
                          IndexName='ServiceNowTicketIndex',
                          KeyConditionExpression='ServiceNowTicket = :ticket',
                          ExpressionAttributeValues={':ticket': servicenow_ticket},
                          ScanIndexForward=False,
                          Limit=1
                      )
                      items = response.get('Items', [])
                      item = items[0] if items else None
                  
                  if not item:
                      log('WARN', 'Request not found', requestId=request_id, ticket=servicenow_ticket)
                      return {
                          'statusCode': 404,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'success': False, 'error': 'Request not found'})
                      }
                  
                  response_data = {
                      'success': True,
                      'requestId': item['RequestId'],
                      'serviceNowTicket': item.get('ServiceNowTicket', ''),
                      'vaultName': item.get('VaultName', ''),
                      'userEmail': item.get('UserEmail', ''),
                      'status': item.get('Status', 'unknown'),
                      'requester': item.get('Requester', ''),
                      'createdAt': item.get('CreatedAt', ''),
                      'completedAt': item.get('CompletedAt', ''),
                      'result': item.get('Result', {})
                  }
                  
                  log('INFO', 'Status returned', requestId=item['RequestId'], status=item.get('Status'))
                  
                  return {
                      'statusCode': 200,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps(response_data)
                  }
              except Exception as e:
                  log('ERROR', 'Unexpected error', error=str(e))
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'success': False, 'error': str(e)})
                  }

  # ==========================================================================
  # API GATEWAY
  # ==========================================================================
  
  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchRole.Arn

  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AWS::StackName}-ServiceNowAPI"
      Description: API for ServiceNow 1Password vault integration
      EndpointConfiguration:
        Types:
          - REGIONAL
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    Condition: UseApiKey
    Properties:
      Name: !Sub "${AWS::StackName}-ServiceNowApiKey"
      Description: API Key for ServiceNow authentication
      Enabled: true
      Value: !Ref ApiKeyValue
      Tags:
        - Key: Application
          Value: VaultAutomation

  UsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    Condition: UseApiKey
    Properties:
      UsagePlanName: !Sub "${AWS::StackName}-ServiceNowUsagePlan"
      ApiStages:
        - ApiId: !Ref RestApi
          Stage: !Ref ApiStage
      Throttle:
        BurstLimit: 100
        RateLimit: 50
      Quota:
        Limit: 10000
        Period: DAY

  UsagePlanKey:
    Type: AWS::ApiGateway::UsagePlanKey
    Condition: UseApiKey
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref UsagePlan

  RequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties:
      RestApiId: !Ref RestApi
      ValidateRequestBody: true
      ValidateRequestParameters: true

  VaultResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt RestApi.RootResourceId
      RestApiId: !Ref RestApi
      PathPart: vault

  StatusResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt RestApi.RootResourceId
      RestApiId: !Ref RestApi
      PathPart: status

  VaultPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: POST
      ResourceId: !Ref VaultResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      ApiKeyRequired: !If [UseApiKey, true, false]
      RequestValidatorId: !Ref RequestValidator
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateVaultLambda.Arn}/invocations

  StatusGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: GET
      ResourceId: !Ref StatusResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      ApiKeyRequired: !If [UseApiKey, true, false]
      RequestValidatorId: !Ref RequestValidator
      RequestParameters:
        method.request.querystring.requestId: false
        method.request.querystring.serviceNowTicket: false
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetStatusLambda.Arn}/invocations

  VaultOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref VaultResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Api-Key,X-Request-Id'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  StatusOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref StatusResource
      RestApiId: !Ref RestApi
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Api-Key,X-Request-Id'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - VaultPostMethod
      - StatusGetMethod
      - VaultOptionsMethod
      - StatusOptionsMethod
    Properties:
      RestApiId: !Ref RestApi
      Description: !Sub "ServiceNow API deployment - ${AWS::StackName}"

  ApiStage:
    Type: AWS::ApiGateway::Stage
    DependsOn: ApiGatewayAccount
    Properties:
      StageName: !Ref StageName
      DeploymentId: !Ref ApiDeployment
      RestApiId: !Ref RestApi
      TracingEnabled: true
      MethodSettings:
        - ResourcePath: /*
          HttpMethod: '*'
          LoggingLevel: INFO
          DataTraceEnabled: true
          MetricsEnabled: true
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  # ==========================================================================
  # LAMBDA PERMISSIONS
  # ==========================================================================
  
  CreateVaultLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref CreateVaultLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/*/*'

  GetStatusLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref GetStatusLambda
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/*/*'

  # ==========================================================================
  # WAF (WEB APPLICATION FIREWALL)
  # ==========================================================================
  
  AllowedIPSet:
    Type: AWS::WAFv2::IPSet
    Properties:
      Scope: REGIONAL
      IPAddressVersion: IPV4
      Addresses: !Ref AllowedIPRanges
      Description: Allowed IP ranges for API access
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  ApiWAF:
    Type: AWS::WAFv2::WebACL
    Properties:
      Scope: REGIONAL
      DefaultAction:
        Block: {}
      Description: WAF for 1Password Vault API
      Rules:
        - Name: AllowWhitelistedIPs
          Priority: 1
          Statement:
            IPSetReferenceStatement:
              Arn: !GetAtt AllowedIPSet.Arn
          Action:
            Allow: {}
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AllowedIPsRule
        - Name: RateLimitPerIP
          Priority: 2
          Statement:
            RateBasedStatement:
              Limit: 100
              AggregateKeyType: IP
          Action:
            Block:
              CustomResponse:
                ResponseCode: 429
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: RateLimitRule
        - Name: AWSManagedCommonRules
          Priority: 3
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
              ExcludedRules: []
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedCommonRules
        - Name: AWSManagedKnownBadInputs
          Priority: 4
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesKnownBadInputsRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedKnownBadInputs
      VisibilityConfig:
        SampledRequestsEnabled: true
        CloudWatchMetricsEnabled: true
        MetricName: !Sub "${AWS::StackName}-WAF"
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  ApiWAFAssociation:
    Type: AWS::WAFv2::WebACLAssociation
    DependsOn: 
      - ApiStage
      - ApiWAF
    Properties:
      ResourceArn: !Sub "arn:aws:apigateway:${AWS::Region}::/restapis/${RestApi}/stages/${StageName}"
      WebACLArn: !GetAtt ApiWAF.Arn

  WAFLogging:
    Type: AWS::WAFv2::LoggingConfiguration
    DependsOn: WAFLogGroup
    Properties:
      ResourceArn: !GetAtt ApiWAF.Arn
      LogDestinationConfigs:
        - !GetAtt WAFLogGroup.Arn

  # ==========================================================================
  # MONITORING & ALERTS
  # ==========================================================================
  
  AlertTopic:
    Type: AWS::SNS::Topic
    Condition: EnableAlerts
    Properties:
      DisplayName: !Sub "${AWS::StackName} Alerts"
      Subscription:
        - Endpoint: !Ref AlertEmail
          Protocol: email
      Tags:
        - Key: Application
          Value: VaultAutomation
        - Key: ManagedBy
          Value: CloudFormation

  CreateVaultErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnableAlerts
    Properties:
      AlarmName: !Sub "${AWS::StackName}-CreateVault-Errors"
      AlarmDescription: Alert when vault creation has multiple errors
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref CreateVaultLambda
      AlarmActions:
        - !Ref AlertTopic
      TreatMissingData: notBreaching

  CreateVaultThrottleAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnableAlerts
    Properties:
      AlarmName: !Sub "${AWS::StackName}-CreateVault-Throttles"
      AlarmDescription: Alert when vault creation is being throttled
      MetricName: Throttles
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 3
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref CreateVaultLambda
      AlarmActions:
        - !Ref AlertTopic
      TreatMissingData: notBreaching

  WAFBlockAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnableAlerts
    Properties:
      AlarmName: !Sub "${AWS::StackName}-WAF-Blocks"
      AlarmDescription: Alert when WAF blocks requests
      MetricName: BlockedRequests
      Namespace: AWS/WAFV2
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 10
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: WebACL
          Value: !Ref ApiWAF
        - Name: Region
          Value: !Ref AWS::Region
        - Name: Rule
          Value: ALL
      AlarmActions:
        - !Ref AlertTopic
      TreatMissingData: notBreaching

  WAFRateLimitAlarm:
    Type: AWS::CloudWatch::Alarm
    Condition: EnableAlerts
    Properties:
      AlarmName: !Sub "${AWS::StackName}-WAF-RateLimit"
      AlarmDescription: Alert when rate limiting is triggered
      MetricName: RateLimitRule
      Namespace: AWS/WAFV2
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: WebACL
          Value: !Ref ApiWAF
        - Name: Region
          Value: !Ref AWS::Region
        - Name: Rule
          Value: RateLimitPerIP
      AlarmActions:
        - !Ref AlertTopic
      TreatMissingData: notBreaching

# ============================================================================
# OUTPUTS
# ============================================================================

Outputs:
  ApiURL:
    Description: Base URL for ServiceNow API
    Value: !Sub https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}
    Export:
      Name: !Sub "${AWS::StackName}-ApiUrl"
  
  CreateVaultEndpoint:
    Description: POST endpoint to create vaults
    Value: !Sub https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}/vault
  
  StatusEndpoint:
    Description: GET endpoint to check request status
    Value: !Sub https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}/status
  
  ApiKeyId:
    Condition: UseApiKey
    Description: API Key ID (retrieve value from AWS Console or CLI)
    Value: !Ref ApiKey
  
  DynamoDBTable:
    Description: DynamoDB table for tracking requests
    Value: !Ref RequestsTable
    Export:
      Name: !Sub "${AWS::StackName}-RequestsTable"
  
  CreateVaultLambdaArn:
    Description: ARN of the CreateVault Lambda function
    Value: !GetAtt CreateVaultLambda.Arn
    Export:
      Name: !Sub "${AWS::StackName}-CreateVaultLambdaArn"
  
  AlertTopicArn:
    Condition: EnableAlerts
    Description: SNS Topic ARN for alerts
    Value: !Ref AlertTopic
    Export:
      Name: !Sub "${AWS::StackName}-AlertTopicArn"

  WAFWebACLId:
    Description: WAF Web ACL ID
    Value: !GetAtt ApiWAF.Id
    Export:
      Name: !Sub "${AWS::StackName}-WAFId"
  
  WAFWebACLArn:
    Description: WAF Web ACL ARN
    Value: !GetAtt ApiWAF.Arn
    Export:
      Name: !Sub "${AWS::StackName}-WAFArn"
  
  AllowedIPRanges:
    Description: Currently allowed IP ranges
    Value: !Join [', ', !Ref AllowedIPRanges]

  UsageInstructions:
    Description: How to use this API
    Value: !Sub |
 