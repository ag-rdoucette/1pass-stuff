AWSTemplateFormatVersion: "2010-09-09"
Description: >
  1Password Event Monitoring & Alerting System — fully self-contained.
  Everything is defined here: IAM, Secrets Manager, SSM, S3, EventBridge,
  Lambda, and SES. The Processor Lambda pip-installs onepassword-sdk into
  /tmp on cold start — no Layers, no custom resources for packaging, no
  external artifacts required.

# ─────────────────────────────────────────────────────────────────────────────
# PARAMETERS
# ─────────────────────────────────────────────────────────────────────────────
Parameters:
  OnePasswordVaultId:
    Type: String
    Description: >
      The UUID of the 1Password vault where Secure Notes will be created.
      (Settings → Vaults → select vault → Copy Vault ID)
    AllowedPattern: "[a-z0-9]{26}"
    ConstraintDescription: "26-character lowercase alphanumeric vault ID."

  SesVerifiedSenderEmail:
    Type: String
    Description: "A verified SES sender email (e.g. alerts@yourdomain.com)."
    AllowedPattern: "^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$"

  AlertNotifyEmail:
    Type: String
    Description: "Email address that will receive alert notifications."
    AllowedPattern: "^[a-zA-Z0-9._%+\\-]+@[a-zA-Z0-9.\\-]+\\.[a-zA-Z]{2,}$"

  MonitoredUserEmail:
    Type: String
    Description: "The 1Password user email to monitor for sign-ins (e.g. ron.doucette@agilebits.com)."
    Default: "ron.doucette@agilebits.com"

  PollIntervalMinutes:
    Type: Number
    Description: "How often (in minutes) to poll the 1Password Events API."
    Default: 5
    MinValue: 1
    MaxValue: 60

  OnePasswordEventsApiToken:
    Type: String
    Description: >
      Bearer token for the 1Password Events API.
      (1Password Settings → Events → Generate token)
    NoEcho: true

  OnePasswordRegionDomain:
    Type: String
    Description: >
      The regional domain for your 1Password account.
      Choose based on where your account is hosted.
    Default: "1password.com"
    AllowedValues:
      - "1password.com"
      - "1password.ca"
      - "1password.eu"

  OnePasswordEventTypes:
    Type: CommaDelimitedList
    Description: >
      The types of events to monitor (comma-separated).
      signinattempts = user sign-in events
      auditevents = all audit events (creates, updates, deletes, etc.)
      itemusages = item access events
      Leave all three to monitor everything, or remove types you don't need.
    Default: "signinattempts,auditevents,itemusages"

  OnePasswordSdkServiceAccountToken:
    Type: String
    Description: >
      Service Account token for the 1Password Python SDK.
      (1Password Settings → Service Accounts → select account → Manage tokens)
    NoEcho: true

  Environment:
    Type: String
    Default: "prod"
    AllowedValues: [dev, staging, prod]

# ─────────────────────────────────────────────────────────────────────────────
# CONDITIONS
# ─────────────────────────────────────────────────────────────────────────────
Conditions:
  IsProd: !Equals [!Ref Environment, "prod"]

# ─────────────────────────────────────────────────────────────────────────────
# SECRETS MANAGER
# ─────────────────────────────────────────────────────────────────────────────
Resources:

  BearerTokenSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "1password-events-bearer-token-${Environment}"
      Description: "Bearer token for the 1Password Events API."
      SecretString: !Sub '{"token":"${OnePasswordEventsApiToken}"}'
      Tags:
        - Key: Application
          Value: "1password-alert-system"

  SdkTokenSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "1password-sdk-service-account-token-${Environment}"
      Description: "Service Account token for the 1Password Python SDK."
      SecretString: !Sub '{"token":"${OnePasswordSdkServiceAccountToken}"}'
      Tags:
        - Key: Application
          Value: "1password-alert-system"

# ─────────────────────────────────────────────────────────────────────────────
# SSM — Cursors (created dynamically by Poller, one per event type)
# ─────────────────────────────────────────────────────────────────────────────
# Cursors are now managed at:
#   /1password-alert-system/${Environment}/cursors/signinattempts
#   /1password-alert-system/${Environment}/cursors/auditevents
#   /1password-alert-system/${Environment}/cursors/itemusages
# The Poller creates them on-demand during its first poll.

# ─────────────────────────────────────────────────────────────────────────────
# S3 BUCKET
# ─────────────────────────────────────────────────────────────────────────────
  EventsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "1password-events-${Environment}-${AWS::AccountId}"
      AccessControl: Private
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
            BucketKeyEnabled: true
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: ArchiveOldEvents
            Status: Enabled
            Transitions:
              - TransitionInDays: 90
                StorageClass: STANDARD_IA
              - TransitionInDays: 365
                StorageClass: GLACIER
            ExpirationInDays: 730
      Tags:
        - Key: Application
          Value: "1password-alert-system"
        - Key: Environment
          Value: !Ref Environment

  EventsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref EventsBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: DenyUnencryptedUploads
            Effect: Deny
            Principal: "*"
            Action: "s3:PutObject"
            Resource: !Sub "arn:aws:s3:::${EventsBucket}/*"
            Condition:
              StringNotEquals:
                "s3:x-amz-server-side-encryption": "aws:kms"
          - Sid: DenyNonTLS
            Effect: Deny
            Principal: "*"
            Action: "s3:*"
            Resource:
              - !Sub "arn:aws:s3:::${EventsBucket}"
              - !Sub "arn:aws:s3:::${EventsBucket}/*"
            Condition:
              Bool:
                "aws:SecureTransport": "false"

# ─────────────────────────────────────────────────────────────────────────────
# CUSTOM RESOURCE: Upload alert_rules.json to S3 at deploy time
# ─────────────────────────────────────────────────────────────────────────────
  # The rules content is built from the CF parameters so it stays in-template.
  RulesUploaderRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: WriteRules
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: "s3:PutObject"
                Resource: !Sub "arn:aws:s3:::${EventsBucket}/rules/*"

  RulesUploaderFunction:
    Type: AWS::Lambda::Function
    DependsOn: RulesUploaderLogGroup
    Properties:
      FunctionName: !Sub "1password-rules-uploader-${Environment}"
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt RulesUploaderRole.Arn
      Timeout: 30
      Code:
        ZipFile: |
          import json, os, urllib.request, boto3
          from datetime import datetime, timezone

          s3 = boto3.client("s3")


          def send_cfn_response(event, context, status, reason="", data=None):
              """
              POST the response back to CloudFormation's presigned ResponseURL.
              cfnresponse is NOT available in the Lambda runtime when using
              inline ZipFile code, so this replicates what it does.
              """
              response_url = event["ResponseURL"]
              stack_id     = event["StackId"]
              request_id   = event["RequestId"]
              logical_id   = event["LogicalResourceId"]
              physical_id  = event.get("PhysicalResourceId", context.function_name)

              body = json.dumps({
                  "Status":             status,
                  "Reason":             reason or (f"See logs: {context.log_group_name}/{context.log_stream_name}" if status == "FAILED" else "OK"),
                  "PhysicalResourceId": physical_id,
                  "StackId":            stack_id,
                  "RequestId":          request_id,
                  "LogicalResourceId":  logical_id,
                  "Data":               data or {},
              })

              print(f"Sending {status} response to CloudFormation...")
              req = urllib.request.Request(
                  response_url,
                  data=body.encode("utf-8"),
                  headers={
                      "Content-Type": "",   # S3 presigned URL requires empty content-type
                      "Content-Length": str(len(body)),
                  },
                  method="PUT",
              )
              urllib.request.urlopen(req, timeout=10)


          def handler(event, context):
              import traceback

              # If this isn't a CF custom-resource event (e.g. a manual test
              # invoke from the console), just exit.  Without this guard a
              # missing RequestType raises KeyError before we can send any
              # response back to CF.
              if "RequestType" not in event:
                  print(f"Not a CF custom-resource event (keys: {list(event.keys())}). Exiting.")
                  return {"statusCode": 200, "body": "no-op"}

              status = "SUCCESS"
              try:
                  if event["RequestType"] in ("Create", "Update"):
                      bucket = event["ResourceProperties"]["Bucket"]
                      rules  = event["ResourceProperties"]["Rules"]
                      s3.put_object(
                          Bucket=bucket,
                          Key="rules/alert_rules.json",
                          Body=rules.encode("utf-8"),
                          ContentType="application/json",
                          ServerSideEncryption="aws:kms",
                      )
                      print(f"Uploaded alert_rules.json to s3://{bucket}/rules/")
                  else:
                      # Delete is a no-op — the bucket lifecycle handles cleanup.
                      print(f"RequestType={event['RequestType']} — no action needed.")
              except Exception:
                  traceback.print_exc()
                  status = "FAILED"
              finally:
                  try:
                      send_cfn_response(event, context, status)
                  except Exception:
                      traceback.print_exc()

  # Trigger: runs on Create and Update so rules stay in sync with parameters.
  RulesUploadTrigger:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: EventsBucket
    Properties:
      ServiceToken: !GetAtt RulesUploaderFunction.Arn
      Bucket: !Ref EventsBucket
      # Build the rules JSON right here from parameters.
      # To add more monitored users later, update this list and run
      # `aws cloudformation update-stack ...` with the same template.
      Rules: !Sub |
        {
          "_comment": "Managed by CloudFormation. Update via stack parameters or edit this section and update the stack.",
          "signin_alerts": [
            {
              "email": "${MonitoredUserEmail}",
              "note_title": "Security Alert: ${MonitoredUserEmail} Sign-In Detected",
              "tags": ["security", "signin-alert", "monitored-user"],
              "notify_email": "${AlertNotifyEmail}"
            }
          ],
          "event_type_alerts": []
        }

# ─────────────────────────────────────────────────────────────────────────────
# CLOUDWATCH LOG GROUPS
# ─────────────────────────────────────────────────────────────────────────────
  PollerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/1password-event-poller-${Environment}"
      RetentionInDays: !If [IsProd, 90, 30]

  ProcessorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/1password-event-processor-${Environment}"
      RetentionInDays: !If [IsProd, 90, 30]

  RulesUploaderLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/aws/lambda/1password-rules-uploader-${Environment}"
      RetentionInDays: 7

# ─────────────────────────────────────────────────────────────────────────────
# IAM ROLES — Poller & Processor
# ─────────────────────────────────────────────────────────────────────────────
  PollerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "1password-poller-role-${Environment}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: PollerPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: ReadBearerToken
                Effect: Allow
                Action: "secretsmanager:GetSecretValue"
                Resource: !Ref BearerTokenSecret
              - Sid: ManageCursor
                Effect: Allow
                Action:
                  - "ssm:GetParameter"
                  - "ssm:PutParameter"
                Resource: !Sub "arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/1password-alert-system/${Environment}/cursors/*"
              - Sid: WriteEventsToS3
                Effect: Allow
                Action: "s3:PutObject"
                Resource: !Sub "arn:aws:s3:::${EventsBucket}/events/*"
              - Sid: InvokeProcessor
                Effect: Allow
                Action: "lambda:InvokeFunction"
                Resource: !GetAtt ProcessorFunction.Arn

  ProcessorExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "1password-processor-role-${Environment}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ProcessorPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: ReadFromS3
                Effect: Allow
                Action: "s3:GetObject"
                Resource:
                  - !Sub "arn:aws:s3:::${EventsBucket}/events/*"
                  - !Sub "arn:aws:s3:::${EventsBucket}/rules/*"
              - Sid: ReadSdkToken
                Effect: Allow
                Action: "secretsmanager:GetSecretValue"
                Resource: !Ref SdkTokenSecret
              - Sid: SendSesEmails
                Effect: Allow
                Action: "ses:SendEmail"
                Resource: "*"

# ─────────────────────────────────────────────────────────────────────────────
# LAMBDA — Poller
# ─────────────────────────────────────────────────────────────────────────────
  PollerFunction:
    Type: AWS::Lambda::Function
    DependsOn: PollerLogGroup
    Properties:
      FunctionName: !Sub "1password-event-poller-${Environment}"
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt PollerExecutionRole.Arn
      Timeout: 60
      MemorySize: 256
      Code:
        ZipFile: |
          import json, os, boto3, urllib.request, urllib.error
          from datetime import datetime, timezone

          secrets_client  = boto3.client("secretsmanager")
          ssm_client      = boto3.client("ssm")
          s3_client       = boto3.client("s3")
          lambda_client   = boto3.client("lambda")

          REGION_DOMAIN             = os.environ["REGION_DOMAIN"]
          EVENT_TYPES               = os.environ["EVENT_TYPES"].split(",")
          BEARER_TOKEN_SECRET_ARN   = os.environ["BEARER_TOKEN_SECRET_ARN"]
          CURSOR_SSM_PARAM_PREFIX   = os.environ["CURSOR_SSM_PARAM_PREFIX"]
          S3_BUCKET                 = os.environ["S3_BUCKET"]
          S3_PREFIX                 = os.environ.get("S3_PREFIX", "events/")
          PROCESSOR_FUNCTION_NAME   = os.environ["PROCESSOR_FUNCTION_NAME"]


          def get_bearer_token():
              secret = secrets_client.get_secret_value(SecretId=BEARER_TOKEN_SECRET_ARN)
              return json.loads(secret["SecretString"])["token"]


          def get_cursor(event_type):
              """Get the cursor for a specific event type."""
              param_name = f"{CURSOR_SSM_PARAM_PREFIX}/{event_type}"
              try:
                  resp  = ssm_client.get_parameter(Name=param_name)
                  value = resp["Parameter"]["Value"]
                  return None if (not value or value == "NONE") else value
              except ssm_client.exceptions.ParameterNotFound:
                  return None


          def save_cursor(event_type, cursor):
              """Save the cursor for a specific event type."""
              param_name = f"{CURSOR_SSM_PARAM_PREFIX}/{event_type}"
              ssm_client.put_parameter(
                  Name=param_name,
                  Value=cursor if cursor else "NONE",
                  Type="String",
                  Overwrite=True,
              )


          def fetch_events(bearer_token, event_type, cursor):
              """Fetch events from a specific event type endpoint."""
              endpoint = f"https://events.{REGION_DOMAIN}/api/v2/{event_type}"
              headers = {
                  "Authorization": f"Bearer {bearer_token}",
                  "Content-Type": "application/json",
                  "Accept": "application/json",
              }
              body = {}
              if cursor:
                  body["cursor"] = cursor

              req = urllib.request.Request(
                  endpoint,
                  data=json.dumps(body).encode("utf-8"),
                  headers=headers,
                  method="POST",
              )
              try:
                  with urllib.request.urlopen(req, timeout=30) as resp:
                      data = json.loads(resp.read().decode("utf-8"))
                      
                      # DEBUG: Log the raw API response structure
                      print(f"[{event_type}] API Response keys: {list(data.keys())}")
                      print(f"[{event_type}] has_more: {data.get('has_more', 'N/A')}")
                      print(f"[{event_type}] cursor present: {bool(data.get('cursor'))}")
                      
                      # Check what field name contains the events
                      items_count = len(data.get("items", []))
                      events_count = len(data.get("events", []))
                      print(f"[{event_type}] 'items' field count: {items_count}")
                      print(f"[{event_type}] 'events' field count: {events_count}")
                      
                      # If items exist, show a sample
                      if items_count > 0:
                          sample = data["items"][0]
                          print(f"[{event_type}] Sample item keys: {list(sample.keys())[:10]}")
                          if "target_user" in sample:
                              print(f"[{event_type}] Sample email: {sample.get('target_user', {}).get('email', 'N/A')}")
                      
              except urllib.error.HTTPError as e:
                  err = e.read().decode("utf-8") if e.readable() else ""
                  raise Exception(f"1Password API error {e.code} for {event_type}: {err}")

              return data.get("items", []), data.get("cursor", None)


          def write_to_s3(all_events, event_type_counts):
              """Write aggregated events from all types to S3."""
              if not all_events:
                  return None
              now = datetime.now(timezone.utc)
              key = now.strftime(f"{S3_PREFIX}%Y/%m/%d/%H-%M-%S") + ".json"
              payload = {
                  "_metadata": {
                      "fetched_at": now.isoformat(),
                      "total_events": len(all_events),
                      "event_type_counts": event_type_counts,
                  },
                  "events": all_events,
              }
              s3_client.put_object(
                  Bucket=S3_BUCKET,
                  Key=key,
                  Body=json.dumps(payload, indent=2).encode("utf-8"),
                  ContentType="application/json",
                  ServerSideEncryption="aws:kms",
              )
              return key


          def invoke_processor(bucket, key):
              """Invoke the Processor Lambda directly, passing the S3 location."""
              lambda_client.invoke(
                  FunctionName=PROCESSOR_FUNCTION_NAME,
                  InvocationType="Event",
                  Payload=json.dumps({"bucket": bucket, "key": key}).encode("utf-8"),
              )
              print(f"Invoked Processor for s3://{bucket}/{key}")


          def lambda_handler(event, context):
              print(f"Starting 1Password event poll for types: {EVENT_TYPES}")
              bearer_token = get_bearer_token()

              all_events = []
              event_type_counts = {}

              # Poll each event type separately
              for event_type in EVENT_TYPES:
                  event_type = event_type.strip()
                  cursor = get_cursor(event_type)
                  print(f"[{event_type}] Cursor: {'(none)' if not cursor else cursor[:20] + '...'}")

                  events, next_cursor = fetch_events(bearer_token, event_type, cursor)
                  print(f"[{event_type}] Fetched {len(events)} events.")

                  if events:
                      all_events.extend(events)
                      event_type_counts[event_type] = len(events)

                  if next_cursor:
                      save_cursor(event_type, next_cursor)
                      print(f"[{event_type}] Cursor updated.")

              # Write all events to S3 and trigger processor
              if all_events:
                  s3_key = write_to_s3(all_events, event_type_counts)
                  print(f"Wrote {len(all_events)} total events to S3: s3://{S3_BUCKET}/{s3_key}")
                  invoke_processor(S3_BUCKET, s3_key)
              else:
                  print("No new events from any type.")

              return {
                  "statusCode": 200,
                  "body": json.dumps({
                      "total_events_fetched": len(all_events),
                      "event_type_counts": event_type_counts,
                  }),
              }
      Environment:
        Variables:
          REGION_DOMAIN:            !Ref OnePasswordRegionDomain
          EVENT_TYPES:              !Join [",", !Ref OnePasswordEventTypes]
          BEARER_TOKEN_SECRET_ARN:  !Ref BearerTokenSecret
          CURSOR_SSM_PARAM_PREFIX:  !Sub "/1password-alert-system/${Environment}/cursors"
          S3_BUCKET:                !Ref EventsBucket
          S3_PREFIX:                "events/"
          PROCESSOR_FUNCTION_NAME:  !Ref ProcessorFunction
      Tags:
        - Key: Application
          Value: "1password-alert-system"
        - Key: Environment
          Value: !Ref Environment

# ─────────────────────────────────────────────────────────────────────────────
# LAMBDA — Processor  (invoked directly by the Poller after S3 write)
# ─────────────────────────────────────────────────────────────────────────────
  ProcessorFunction:
    Type: AWS::Lambda::Function
    DependsOn: ProcessorLogGroup
    Properties:
      FunctionName: !Sub "1password-event-processor-${Environment}"
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt ProcessorExecutionRole.Arn
      Timeout: 120
      MemorySize: 512
      Code:
        ZipFile: |
          import json, os, sys, subprocess, asyncio, boto3
          from datetime import datetime, timezone

          # --- Cold-start SDK install (same approach as working reference template) ---
          SDK_INSTALLED = False
          def install_sdk():
              global SDK_INSTALLED
              if SDK_INSTALLED:
                  print("[SDK] Already installed (cached)")
                  return
              sdk_dir = '/tmp/onepassword-sdk'
              if os.path.exists(sdk_dir) and sdk_dir in sys.path:
                  print("[SDK] Directory exists, marking as installed")
                  SDK_INSTALLED = True
                  return
              
              print(f"[SDK] Installing to {sdk_dir}...")
              try:
                  result = subprocess.run([
                      sys.executable, '-m', 'pip', 'install',
                      '--target', sdk_dir,
                      '--upgrade',
                      'onepassword-sdk'
                  ], check=True, capture_output=True, text=True)
                  print(f"[SDK] pip succeeded")
              except subprocess.CalledProcessError as e:
                  print(f"[SDK] pip FAILED: {e}")
                  print(f"[SDK] stderr: {e.stderr[:200]}")
              except Exception as e:
                  print(f"[SDK] Unexpected error: {e}")
              
              if sdk_dir not in sys.path:
                  sys.path.insert(0, sdk_dir)
                  print(f"[SDK] Added to sys.path")
              
              # Inspect what was installed
              if os.path.exists(sdk_dir):
                  contents = os.listdir(sdk_dir)
                  print(f"[SDK] Directory contents ({len(contents)} items): {contents}")
                  
                  # Check for onepassword directory
                  if 'onepassword' in contents:
                      op_path = os.path.join(sdk_dir, 'onepassword')
                      if os.path.isdir(op_path):
                          op_contents = os.listdir(op_path)
                          print(f"[SDK] onepassword/ contents: {op_contents}")
                  else:
                      print("[SDK] WARNING: 'onepassword' directory NOT found!")
              
              SDK_INSTALLED = True
              print(f"[SDK] Installation complete")

          s3_client      = boto3.client("s3")
          ses_client     = boto3.client("ses")
          secrets_client = boto3.client("secretsmanager")

          S3_BUCKET            = os.environ["S3_BUCKET"]
          RULES_S3_KEY         = os.environ["RULES_S3_KEY"]
          SDK_TOKEN_SECRET_ARN = os.environ["SDK_TOKEN_SECRET_ARN"]
          VAULT_ID             = os.environ["VAULT_ID"]
          SES_SENDER_EMAIL     = os.environ["SES_SENDER_EMAIL"]


          def load_alert_rules():
              resp = s3_client.get_object(Bucket=S3_BUCKET, Key=RULES_S3_KEY)
              return json.loads(resp["Body"].read().decode("utf-8"))


          def get_sdk_token():
              secret = secrets_client.get_secret_value(SecretId=SDK_TOKEN_SECRET_ARN)
              return json.loads(secret["SecretString"])["token"]


          def match_events(events, rules):
              matches = []
              signin_emails     = {r["email"].lower(): r for r in rules.get("signin_alerts", [])}
              event_type_alerts = {r["event_type"]: r for r in rules.get("event_type_alerts", [])}

              for ev in events:
                  ev_type = ev.get("type", "")

                  # --- Signin alert ---
                  # Sign-in events from the signinattempts endpoint always have 'target_user'
                  target_user = ev.get("target_user")
                  if target_user:
                      actor_email = target_user.get("email", "").lower()
                      if actor_email and actor_email in signin_emails:
                          matches.append((ev, signin_emails[actor_email]))
                          print(f"MATCH (signin): {actor_email} at {ev.get('timestamp', 'unknown')}")
                          continue

                  # --- Event-type alert ---
                  if ev_type in event_type_alerts:
                      matches.append((ev, event_type_alerts[ev_type]))
                      print(f"MATCH (event_type): {ev_type} at {ev.get('timestamp', 'unknown')}")

              return matches


          async def create_secure_note(sdk_token, event, rule):
              # Lazy import SDK modules - they should be installed by now
              try:
                  from onepassword.client import Client
                  from onepassword import ItemCreateParams, ItemField
              except ImportError as e:
                  print(f"SDK import failed: {e}")
                  raise
              
              client = await Client.authenticate(
                  auth=sdk_token,
                  integration_name="AWS 1Password Alert System",
                  integration_version="v1.0.0",
              )

              timestamp = event.get("timestamp", datetime.now(timezone.utc).isoformat())
              ev_type   = event.get("type", "unknown")
              category  = event.get("category", "unknown")
              
              # Target user info
              target_user = event.get("target_user", {})
              user_name = target_user.get("name", "Unknown")
              user_email = target_user.get("email", "Unknown")
              
              # Location info
              location = event.get("location", {})
              city = location.get("city", "Unknown")
              region = location.get("region", "Unknown")
              country = location.get("country", "Unknown")
              ip_address = event.get("client", {}).get("ip_address", "Unknown")
              
              # Client info
              event_client = event.get("client", {})
              app_name = event_client.get("app_name", "Unknown")
              platform = event_client.get("platform_name", "Unknown")
              os_name = event_client.get("os_name", "Unknown")
              os_version = event_client.get("os_version", "Unknown")

              status_icon = "SUCCESS" if category == "success" else "FAILED"
              separator = "============================================================"
              nl = chr(10)
              
              note_content = "1Password Security Alert" + nl
              note_content += separator + nl + nl
              note_content += "EVENT SUMMARY" + nl
              note_content += "  Timestamp:    " + timestamp + nl
              note_content += "  Category:     " + category + nl
              note_content += "  Event Type:   " + ev_type + nl
              note_content += "  Status:       " + status_icon + nl + nl
              note_content += "USER INFORMATION" + nl
              note_content += "  Name:         " + user_name + nl
              note_content += "  Email:        " + user_email + nl + nl
              note_content += "LOCATION & DEVICE" + nl
              note_content += "  Location:     " + city + ", " + region + ", " + country + nl
              note_content += "  IP Address:   " + ip_address + nl + nl
              note_content += "  Device:       " + app_name + nl
              note_content += "  Platform:     " + platform + nl
              note_content += "  OS:           " + os_name + " " + os_version + nl + nl
              note_content += separator + nl
              note_content += "Event UUID: " + event.get('uuid', 'Unknown') + nl
              note_content += "Session UUID: " + event.get('session_uuid', 'Unknown') + nl
              note_content += "Account UUID: " + event.get('account_uuid', 'Unknown') + nl + nl
              note_content += "Raw Event Data (for reference):" + nl
              note_content += json.dumps(event, indent=2)

              title = f"{rule['note_title']} [{timestamp[:19]}]"
              tags  = rule.get("tags", ["security-alert"])
              
              # Debug: Check the client structure
              print(f"[DEBUG] client type: {type(client)}")
              print(f"[DEBUG] client.items type: {type(client.items)}")
              print(f"[DEBUG] hasattr create: {hasattr(client.items, 'create')}")
              
              # Try the documented approach - vault_id is IN the ItemCreateParams
              item_params = ItemCreateParams(
                  title=title,
                  category="SecureNote",
                  vault_id=VAULT_ID,
                  fields=[
                      ItemField(
                          id="notesPlain",
                          title="notesPlain",
                          field_type="Text",
                          value=note_content,
                      )
                  ],
                  tags=tags,
              )

              created = await client.items.create(item_params)
              print(f"Created Secure Note: '{title}' (ID: {created.id})")
              return created


          def send_alert_email(event, rule, note_title):
              recipient    = rule.get("notify_email", SES_SENDER_EMAIL)
              timestamp    = event.get("timestamp", "unknown")
              ev_type      = event.get("type", "unknown")
              actor_email  = event.get("actor", {}).get("email", "unknown")
              subject      = f"[1Password Alert] {rule.get('note_title', 'Security Event Detected')}"

              text_body = (
                  f"1Password Security Alert\n"
                  f"{'=' * 40}\n\n"
                  f"Timestamp:   {timestamp}\n"
                  f"Event Type:  {ev_type}\n"
                  f"Actor:       {actor_email}\n\n"
                  f"A Secure Note has been created in 1Password.\n"
                  f"Note Title:  {note_title}\n\n"
                  f"--- Event Summary ---\n"
                  f"{json.dumps(event, indent=2)}\n"
              )

              html_body = f"""<html>
              <head><style>
                  body {{ font-family: Arial, sans-serif; color: #333; max-width: 680px; margin: 0 auto; padding: 20px; }}
                  .header {{ background: #D32F2F; color: #fff; padding: 18px 24px; border-radius: 6px 6px 0 0; }}
                  .header h2 {{ margin: 0; font-size: 18px; }}
                  .body {{ border: 1px solid #ddd; border-top: none; padding: 24px; border-radius: 0 0 6px 6px; }}
                  .row {{ display: flex; padding: 8px 0; border-bottom: 1px solid #eee; }}
                  .label {{ font-weight: bold; width: 120px; color: #555; flex-shrink: 0; }}
                  .value {{ color: #333; word-break: break-all; }}
                  .note-box {{ background: #f0f4ff; border: 1px solid #c5d5ff; border-radius: 6px; padding: 14px 18px; margin-top: 20px; }}
                  .note-box strong {{ color: #2a4cb5; }}
                  pre {{ background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; padding: 14px; overflow-x: auto; font-size: 13px; margin-top: 16px; }}
                  .footer {{ color: #999; font-size: 12px; margin-top: 24px; }}
              </style></head>
              <body>
                  <div class="header"><h2>1Password Security Alert</h2></div>
                  <div class="body">
                      <div class="row"><div class="label">Timestamp</div><div class="value">{timestamp}</div></div>
                      <div class="row"><div class="label">Event Type</div><div class="value">{ev_type}</div></div>
                      <div class="row"><div class="label">Actor</div><div class="value">{actor_email}</div></div>
                      <div class="note-box">
                          <strong>Secure Note Created</strong><br>
                          A Secure Note has been automatically created in 1Password:<br>
                          <em>{note_title}</em>
                      </div>
                      <pre>{json.dumps(event, indent=2)}</pre>
                      <div class="footer">Auto-generated by the AWS 1Password Alert System. Do not reply.</div>
                  </div>
              </body>
              </html>"""

              ses_client.send_email(
                  Source=SES_SENDER_EMAIL,
                  Destination={"ToAddresses": [recipient]},
                  Message={
                      "Subject": {"Data": subject, "Charset": "UTF-8"},
                      "Body": {
                          "Text": {"Data": text_body, "Charset": "UTF-8"},
                          "Html":  {"Data": html_body, "Charset": "UTF-8"},
                      },
                  },
              )
              print(f"Alert email sent to {recipient}")


          def lambda_handler(event, context):
              # Install SDK on first request (matches working reference template pattern)
              install_sdk()
              
              # Guard: check if this is a valid invocation from the Poller
              if "bucket" not in event or "key" not in event:
                  print(f"Invalid event structure. Expected {{bucket, key}}, got: {list(event.keys())}")
                  return {
                      "statusCode": 400,
                      "body": json.dumps({
                          "error": "Missing required fields: bucket and key",
                          "hint": "This function should be invoked by the Poller Lambda with payload: {bucket: '...', key: '...'}"
                      })
                  }
              
              # Payload is the direct JSON we sent from the Poller: {bucket, key}
              bucket = event["bucket"]
              key    = event["key"]
              print(f"Processing: s3://{bucket}/{key}")

              resp     = s3_client.get_object(Bucket=bucket, Key=key)
              payload  = json.loads(resp["Body"].read().decode("utf-8"))
              events   = payload.get("events", [])
              print(f"Loaded {len(events)} events.")

              rules   = load_alert_rules()
              matches = match_events(events, rules)
              print(f"Matches: {len(matches)}")

              if not matches:
                  return {"statusCode": 200, "body": "No alerts triggered."}

              sdk_token = get_sdk_token()

              for matched_event, matched_rule in matches:
                  note_title = matched_rule.get("note_title", "Security Alert")
                  
                  # Try to create Secure Note, but don't let failure block email alerts
                  try:
                      created = asyncio.run(create_secure_note(sdk_token, matched_event, matched_rule))
                      note_title = created.title
                      print(f"Created Secure Note: {note_title}")
                  except Exception as e:
                      print(f"ERROR creating Secure Note: {e}")
                      print(f"Continuing with email alert anyway...")
                  
                  # Always send email alert, even if Secure Note creation failed
                  try:
                      send_alert_email(matched_event, matched_rule, note_title)
                      print(f"Sent email alert to {matched_rule.get('notify_email')}")
                  except Exception as e:
                      print(f"ERROR sending email: {e}")

              return {
                  "statusCode": 200,
                  "body": json.dumps({"alerts_triggered": len(matches)}),
              }
      Environment:
        Variables:
          S3_BUCKET:            !Ref EventsBucket
          RULES_S3_KEY:         "rules/alert_rules.json"
          SDK_TOKEN_SECRET_ARN: !Ref SdkTokenSecret
          VAULT_ID:             !Ref OnePasswordVaultId
          SES_SENDER_EMAIL:     !Ref SesVerifiedSenderEmail
      Tags:
        - Key: Application
          Value: "1password-alert-system"
        - Key: Environment
          Value: !Ref Environment


# ─────────────────────────────────────────────────────────────────────────────
# EVENTBRIDGE — Poll schedule + invoke role
# ─────────────────────────────────────────────────────────────────────────────
  EventBridgeInvokeRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "1password-eventbridge-invoke-role-${Environment}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: InvokePoller
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: "lambda:InvokeFunction"
                Resource: !GetAtt PollerFunction.Arn

  PollerScheduleRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub "1password-poll-schedule-${Environment}"
      Description: !Sub "Polls 1Password Events API every ${PollIntervalMinutes} minute(s)."
      ScheduleExpression: !Sub "rate(${PollIntervalMinutes} minutes)"
      State: ENABLED
      Targets:
        - Id: PollerLambdaTarget
          Arn: !GetAtt PollerFunction.Arn
          RoleArn: !GetAtt EventBridgeInvokeRole.Arn

  PollerSchedulePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PollerFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt PollerScheduleRule.Arn

# ─────────────────────────────────────────────────────────────────────────────
# OUTPUTS
# ─────────────────────────────────────────────────────────────────────────────
Outputs:
  EventsBucketName:
    Description: "S3 bucket for events and rules"
    Value: !Ref EventsBucket
    Export:
      Name: !Sub "1password-alert-events-bucket-${Environment}"

  BearerTokenSecretName:
    Description: "Secrets Manager name for the Events API bearer token."
    Value: !Sub "1password-events-bearer-token-${Environment}"

  SdkTokenSecretName:
    Description: "Secrets Manager name for the SDK service account token."
    Value: !Sub "1password-sdk-service-account-token-${Environment}"

  PollerFunctionName:
    Description: "Poller Lambda function name"
    Value: !Ref PollerFunction

  ProcessorFunctionName:
    Description: "Processor Lambda function name"
    Value: !Ref ProcessorFunction